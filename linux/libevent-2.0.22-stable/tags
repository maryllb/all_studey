!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD_ENTROPY	./arc4random.c	71;"	d	file:
ADD_UDATA	./kqueue.c	174;"	d	file:
ALL_NATIVE_AI_FLAGS	./evutil.c	/^static const unsigned int ALL_NATIVE_AI_FLAGS =$/;"	v	file:
ALL_NONNATIVE_AI_FLAGS	./evutil.c	/^static const unsigned int ALL_NONNATIVE_AI_FLAGS =$/;"	v	file:
APPEND16	./evdns.c	1593;"	d	file:
APPEND16	./evdns.c	2141;"	d	file:
APPEND32	./evdns.c	1600;"	d	file:
APPEND32	./evdns.c	2142;"	d	file:
APPEND_CHAIN	./buffer.c	/^APPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:
ARC4RANDOM_EXPORT	./arc4random.c	45;"	d	file:
ARC4RANDOM_EXPORT	./evutil_rand.c	113;"	d	file:
ARC4RANDOM_NORANDOM	./evutil_rand.c	122;"	d	file:
ARC4RANDOM_NOSTIR	./evutil_rand.c	121;"	d	file:
ARC4RANDOM_NOUNIFORM	./evutil_rand.c	123;"	d	file:
ARC4RANDOM_UINT32	./arc4random.c	49;"	d	file:
ARC4RANDOM_UINT32	./evutil_rand.c	120;"	d	file:
ASSERT_LOCKED	./evdns.c	417;"	d	file:
ASSERT_LOCKED	./evdns.c	423;"	d	file:
ASSERT_VALID_REQUEST	./evdns.c	133;"	d	file:
BIO_TYPE_LIBEVENT	./bufferevent_openssl.c	79;"	d	file:
BIO_new_bufferevent	./bufferevent_openssl.c	/^BIO_new_bufferevent(struct bufferevent *bufferevent, int close_flag)$/;"	f	file:
BIO_s_bufferevent	./bufferevent_openssl.c	/^BIO_s_bufferevent(void)$/;"	f	file:
BYTES_BEFORE_RESEED	./arc4random.c	74;"	d	file:
CHAIN_PINNED	./buffer.c	135;"	d	file:
CHAIN_PINNED_R	./buffer.c	136;"	d	file:
CHAIN_SPACE_LEN	./buffer.c	132;"	d	file:
CHAIN_SPACE_PTR	./buffer.c	131;"	d	file:
CHAR_IS_UNRESERVED	./http.c	2666;"	d	file:
CHUNK_SZ	./buffer.c	1330;"	d	file:
CHUNK_SZ	./buffer.c	1351;"	d	file:
CLAMPTO	./bufferevent_ratelim.c	212;"	d	file:
CLASS_INET	./evdns.c	153;"	d	file:
CLOCK_SYNC_INTERVAL	./event.c	349;"	d	file:
COMMON_TIMEOUT_IDX	./event.c	1098;"	d	file:
COMMON_TIMEOUT_IDX_MASK	./event.c	1093;"	d	file:
COMMON_TIMEOUT_IDX_SHIFT	./event.c	1094;"	d	file:
COMMON_TIMEOUT_MAGIC	./event.c	1096;"	d	file:
COMMON_TIMEOUT_MASK	./event.c	1095;"	d	file:
COPY_CHAIN	./buffer.c	/^COPY_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:
DECODE_INT_INTERNAL	./event_tagging.c	306;"	d	file:
DEFAULT_NFDS	./evport.c	83;"	d	file:
DEFAULT_WRITE_IOVEC	./buffer.c	1992;"	d	file:
DIV_ROUNDUP	./select.c	63;"	d	file:
E	./evutil.c	1472;"	d	file:
E	./evutil.c	1533;"	d	file:
EFD_CLOEXEC	./event.c	2781;"	d	file:
ENCODE_INT_INTERNAL	./event_tagging.c	115;"	d	file:
ERR	./evutil.c	204;"	d	file:
ERR	./evutil.c	291;"	d	file:
ERR_FORMAT	./http.c	2378;"	d	file:
ERR_FORMAT	./http.c	2401;"	d	file:
ERR_FORMAT	./http.c	3043;"	d	file:
ERR_FORMAT	./http.c	3073;"	d	file:
EVBUFFER_CB_INTERNAL_FLAGS	./buffer.c	125;"	d	file:
EVBUFFER_CB_OBSOLETE	./buffer.c	128;"	d	file:
EVBUFFER_CB_USER_FLAGS	./buffer.c	123;"	d	file:
EVBUFFER_CHAIN_MAX_AUTO_SIZE	./buffer.c	1539;"	d	file:
EVBUFFER_MAX_READ	./buffer.c	2016;"	d	file:
EVDNS_LOCK	./evdns.c	415;"	d	file:
EVDNS_LOCK	./evdns.c	419;"	d	file:
EVDNS_LOG_CHECK	./evdns.c	447;"	d	file:
EVDNS_LOG_CHECK	./evdns.c	449;"	d	file:
EVDNS_LOG_DEBUG	./evdns.c	120;"	d	file:
EVDNS_LOG_MSG	./evdns.c	122;"	d	file:
EVDNS_LOG_WARN	./evdns.c	121;"	d	file:
EVDNS_UNLOCK	./evdns.c	416;"	d	file:
EVDNS_UNLOCK	./evdns.c	421;"	d	file:
EVENTS_PER_GETN	./evport.c	91;"	d	file:
EVENT_BASE_ASSERT_LOCKED	./event.c	325;"	d	file:
EVLIST_X_IOFOUND	./evmap.c	732;"	d	file:
EVLIST_X_SIGFOUND	./evmap.c	731;"	d	file:
EVSIGBASE_LOCK	./signal.c	115;"	d	file:
EVSIGBASE_UNLOCK	./signal.c	116;"	d	file:
EVUTIL_AI_LIBEVENT_ALLOCATED	./evutil.c	640;"	d	file:
EVUTIL_ISALNUM_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISALNUM_TABLE[8] =$/;"	v	file:
EVUTIL_ISALPHA_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISALPHA_TABLE[8] =$/;"	v	file:
EVUTIL_ISDIGIT_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISDIGIT_TABLE[8] = { 0, 0x3ff0000, 0, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISLOWER_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISLOWER_TABLE[8] = { 0, 0, 0, 0x7fffffe, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISPRINT_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISPRINT_TABLE[8] =$/;"	v	file:
EVUTIL_ISSPACE_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISSPACE_TABLE[8] = { 0x3e00, 0x1, 0, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISUPPER_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISUPPER_TABLE[8] = { 0, 0, 0x7fffffe, 0, 0, 0, 0, 0 };$/;"	v	file:
EVUTIL_ISXDIGIT_TABLE	./evutil.c	/^static const ev_uint32_t EVUTIL_ISXDIGIT_TABLE[8] =$/;"	v	file:
EVUTIL_TOLOWER_TABLE	./evutil.c	/^static const unsigned char EVUTIL_TOLOWER_TABLE[256] = {$/;"	v	file:
EVUTIL_TOUPPER	./evutil.c	/^char EVUTIL_TOUPPER(char c)$/;"	f
EVUTIL_TOUPPER_TABLE	./evutil.c	/^static const unsigned char EVUTIL_TOUPPER_TABLE[256] = {$/;"	v	file:
EVUTIL_V4ADDR_IS_CLASSD	./evutil.c	546;"	d	file:
EVUTIL_V4ADDR_IS_LOCALHOST	./evutil.c	541;"	d	file:
FDINFO_OFFSET	./evmap.c	184;"	d	file:
FDI_HAS_EVENTS	./evport.c	104;"	d	file:
FDI_HAS_READ	./evport.c	102;"	d	file:
FDI_HAS_WRITE	./evport.c	103;"	d	file:
FDI_TO_SYSEVENTS	./evport.c	105;"	d	file:
FD_SET_ALLOC_SIZE	./win32select.c	97;"	d	file:
FOREACH_RANDOM_ORDER	./bufferevent_ratelim.c	473;"	d	file:
GET16	./evdns.c	1287;"	d	file:
GET16	./evdns.c	949;"	d	file:
GET32	./evdns.c	1286;"	d	file:
GET32	./evdns.c	948;"	d	file:
GET8	./evdns.c	1288;"	d	file:
GET8	./evdns.c	950;"	d	file:
GET_IO_SLOT	./evmap.c	111;"	d	file:
GET_IO_SLOT	./evmap.c	181;"	d	file:
GET_IO_SLOT_AND_CTOR	./evmap.c	119;"	d	file:
GET_IO_SLOT_AND_CTOR	./evmap.c	182;"	d	file:
GET_SIGNAL_SLOT	./evmap.c	159;"	d	file:
GET_SIGNAL_SLOT_AND_CTOR	./evmap.c	166;"	d	file:
GLOBAL	./evthread.c	42;"	d	file:
GLOBAL	./evthread.c	44;"	d	file:
GROUP_SUSPENDED	./bufferevent_ratelim.c	208;"	d	file:
GetNetworkParams_fn_t	./evdns.c	/^typedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);$/;"	t	file:
HAS_PINNED_R	./buffer.c	/^HAS_PINNED_R(struct evbuffer *buf)$/;"	f	file:
HOST_NAME_MAX	./evdns.c	125;"	d	file:
HT_PROTOTYPE	./evmap.c	/^HT_PROTOTYPE(event_io_map, event_map_entry, map_node, hashsocket, eqsocket)$/;"	f
IMPL_CTYPE_FN	./evutil.c	/^IMPL_CTYPE_FN(ISALPHA)$/;"	f
IMPL_CTYPE_FN	./evutil.c	2021;"	d	file:
INITIAL_NEVENT	./epoll.c	96;"	d	file:
INT_TO_UDATA	./kqueue.c	54;"	d	file:
INT_TO_UDATA	./kqueue.c	57;"	d	file:
IOV_LEN_FIELD	./buffer.c	2004;"	d	file:
IOV_LEN_FIELD	./buffer.c	2010;"	d	file:
IOV_LEN_TYPE	./buffer.c	2005;"	d	file:
IOV_LEN_TYPE	./buffer.c	2011;"	d	file:
IOV_PTR_FIELD	./buffer.c	2003;"	d	file:
IOV_PTR_FIELD	./buffer.c	2009;"	d	file:
IOV_TYPE	./buffer.c	2002;"	d	file:
IOV_TYPE	./buffer.c	2008;"	d	file:
InitializeConditionVariable_fn	./evthread_win32.c	/^static void WINAPI (*InitializeConditionVariable_fn)(PCONDITION_VARIABLE)$/;"	v	file:
LIM	./bufferevent_ratelim.c	205;"	d	file:
LOAD	./evthread_win32.c	112;"	d	file:
LOCAL_SOCKETPAIR_AF	./event.c	2804;"	d	file:
LOCK	./listener.c	103;"	d	file:
LOCK_GROUP	./bufferevent_ratelim.c	187;"	d	file:
MAP_FAILED	./buffer.c	96;"	d	file:
MAX_COMMON_TIMEOUTS	./event.c	1179;"	d	file:
MAX_DEFERRED	./event.c	1402;"	d	file:
MAX_DEFERRED	./event.c	1417;"	d	file:
MAX_EPOLL_TIMEOUT_MSEC	./epoll.c	105;"	d	file:
MAX_LABELS	./evdns.c	1517;"	d	file:
MAX_NEVENT	./epoll.c	97;"	d	file:
MAX_PROBE_TIMEOUT	./evdns.c	524;"	d	file:
MAX_SECONDS_IN_MSEC_LONG	./evutil.c	2139;"	d	file:
MAX_TO_COPY_IN_EXPAND	./buffer.c	1728;"	d	file:
MAX_TO_READ_EVER	./bufferevent_ratelim.c	182;"	d	file:
MAX_TO_REALIGN_IN_EXPAND	./buffer.c	1729;"	d	file:
MAX_TO_WRITE_EVER	./bufferevent_ratelim.c	185;"	d	file:
MAX_V4_ADDRS	./evdns.c	143;"	d	file:
MAX_V6_ADDRS	./evdns.c	144;"	d	file:
MAX_WSABUFS	./buffer_iocp.c	49;"	d	file:
MEMBERSOF	./http.c	2581;"	d	file:
MICROSECONDS_MASK	./event.c	1092;"	d	file:
MIN	./evdns.c	130;"	d	file:
MIN	./evdns.c	131;"	d	file:
MIN	./http.c	165;"	d	file:
NEVENT	./devpoll.c	79;"	d	file:
NEVENT	./kqueue.c	67;"	d	file:
NEVENT	./win32select.c	175;"	d	file:
NEXT_TOKEN	./evdns.c	3475;"	d	file:
NEXT_TOKEN	./evdns.c	3508;"	d	file:
NEXT_TOKEN	./evdns.c	4046;"	d	file:
NEXT_TOKEN	./evdns.c	4086;"	d	file:
NFDBITS	./select.c	59;"	d	file:
NI_MAXHOST	./http.c	107;"	d	file:
NI_MAXSERV	./http.c	106;"	d	file:
NI_NUMERICHOST	./http.c	110;"	d	file:
NI_NUMERICSERV	./http.c	114;"	d	file:
NOTIFICATION_KEY	./event_iocp.c	45;"	d	file:
NUM_ERRORS	./bufferevent_openssl.c	306;"	d	file:
NUM_READ_IOVEC	./buffer.c	2014;"	d	file:
NUM_WRITE_IOVEC	./buffer.c	1995;"	d	file:
NUM_WRITE_IOVEC	./buffer.c	1997;"	d	file:
NUM_WRITE_IOVEC	./buffer.c	1999;"	d	file:
NUM_WRITE_IOVEC	./buffer.c	2007;"	d	file:
N_CPUS_DEFAULT	./event_iocp.c	172;"	d	file:
N_SOCKETS_PER_LISTENER	./listener.c	797;"	d	file:
N_TO_READ	./evutil.c	160;"	d	file:
OP_BLOCKED	./bufferevent_openssl.c	560;"	d	file:
OP_ERR	./bufferevent_openssl.c	561;"	d	file:
OP_MADE_PROGRESS	./bufferevent_openssl.c	559;"	d	file:
PART_FRAGMENT	./http.c	/^	PART_FRAGMENT$/;"	e	enum:uri_part	file:
PART_PATH	./http.c	/^	PART_PATH,$/;"	e	enum:uri_part	file:
PART_QUERY	./http.c	/^	PART_QUERY,$/;"	e	enum:uri_part	file:
PREPEND_CHAIN	./buffer.c	/^PREPEND_CHAIN(struct evbuffer *dst, struct evbuffer *src)$/;"	f	file:
PRESERVE_PINNED	./buffer.c	/^PRESERVE_PINNED(struct evbuffer *src, struct evbuffer_chain **first,$/;"	f	file:
PTR_TO_UDATA	./kqueue.c	53;"	d	file:
PTR_TO_UDATA	./kqueue.c	56;"	d	file:
READ_DEFAULT	./bufferevent_openssl.c	715;"	d	file:
REQ_HEAD	./evdns.c	386;"	d	file:
REQ_VERSION_ATLEAST	./http.c	160;"	d	file:
REQ_VERSION_BEFORE	./http.c	156;"	d	file:
RESTORE_PINNED	./buffer.c	/^RESTORE_PINNED(struct evbuffer *src, struct evbuffer_chain *pinned,$/;"	f	file:
SCHEDULE_DEFERRED	./bufferevent.c	210;"	d	file:
SELECT_ALLOC_SIZE	./select.c	66;"	d	file:
SENDFILE_IS_FREEBSD	./buffer.c	105;"	d	file:
SENDFILE_IS_LINUX	./buffer.c	102;"	d	file:
SENDFILE_IS_MACOSX	./buffer.c	108;"	d	file:
SENDFILE_IS_SOLARIS	./buffer.c	111;"	d	file:
SERVICES_KEY	./evdns.c	3745;"	d	file:
SIGFPE_REQ	./win32select.c	/^volatile double SIGFPE_REQ = 0.0f;$/;"	v
SKIP_NAME	./evdns.c	1041;"	d	file:
SKIP_NAME	./evdns.c	1285;"	d	file:
SO_UPDATE_CONNECT_CONTEXT	./bufferevent_async.c	68;"	d	file:
SPIN_COUNT	./evthread_win32.c	46;"	d	file:
SUBDELIMS	./http.c	3959;"	d	file:
SleepConditionVariableCS_fn	./evthread_win32.c	/^static BOOL WINAPI (*SleepConditionVariableCS_fn)($/;"	v	file:
TEST_NAME	./evdns.c	1047;"	d	file:
TIMEOUT_BACKOFF_FACTOR	./evdns.c	525;"	d	file:
TO_SERVER_REQUEST	./evdns.c	382;"	d	file:
TRY	./evdns.c	3754;"	d	file:
TRY	./evdns.c	3802;"	d	file:
TRY_SEED_PROC_SYS_KERNEL_RANDOM_UUID	./arc4random.c	250;"	d	file:
TRY_SEED_SYSCTL_BSD	./arc4random.c	209;"	d	file:
TRY_SEED_SYSCTL_LINUX	./arc4random.c	172;"	d	file:
TRY_SEED_URANDOM	./arc4random.c	295;"	d	file:
TRY_SEED_WIN32	./arc4random.c	144;"	d	file:
TYPE_A	./evdns.c	147;"	d	file:
TYPE_AAAA	./evdns.c	151;"	d	file:
TYPE_CNAME	./evdns.c	148;"	d	file:
TYPE_PTR	./evdns.c	149;"	d	file:
TYPE_SOA	./evdns.c	150;"	d	file:
UNLOCK	./listener.c	104;"	d	file:
UNLOCKED	./bufferevent.c	172;"	d	file:
UNLOCKED	./bufferevent.c	207;"	d	file:
UNLOCK_GROUP	./bufferevent_ratelim.c	188;"	d	file:
USE_INTERNAL_NTOP	./evutil.c	1583;"	d	file:
USE_INTERNAL_PTON	./evutil.c	1584;"	d	file:
USE_IOVEC_IMPL	./buffer.c	1983;"	d	file:
USE_NATIVE_GETADDRINFO	./evutil.c	926;"	d	file:
USE_SENDFILE	./buffer.c	101;"	d	file:
USE_SENDFILE	./buffer.c	104;"	d	file:
USE_SENDFILE	./buffer.c	107;"	d	file:
USE_SENDFILE	./buffer.c	110;"	d	file:
WIN32_LEAN_AND_MEAN	./event.c	31;"	d	file:
WIN32_LEAN_AND_MEAN	./event.c	33;"	d	file:
WIN32_LEAN_AND_MEAN	./event_tagging.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	./event_tagging.c	41;"	d	file:
WIN32_LEAN_AND_MEAN	./evmap.c	30;"	d	file:
WIN32_LEAN_AND_MEAN	./evmap.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	./evrpc.c	30;"	d	file:
WIN32_LEAN_AND_MEAN	./evrpc.c	33;"	d	file:
WIN32_LEAN_AND_MEAN	./evthread_win32.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	./evthread_win32.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	./evutil.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	./evutil.c	36;"	d	file:
WIN32_LEAN_AND_MEAN	./log.c	44;"	d	file:
WIN32_LEAN_AND_MEAN	./log.c	46;"	d	file:
WIN32_LEAN_AND_MEAN	./signal.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	./signal.c	35;"	d	file:
WIN_NS_9X_KEY	./evdns.c	3746;"	d	file:
WIN_NS_NT_KEY	./evdns.c	3747;"	d	file:
WRITE_FRAME	./bufferevent_openssl.c	713;"	d	file:
WSAID_ACCEPTEX	./event_iocp.c	132;"	d	file:
WSAID_CONNECTEX	./event_iocp.c	136;"	d	file:
WSAID_GETACCEPTEXSOCKADDRS	./event_iocp.c	140;"	d	file:
WakeAllConditionVariable_fn	./evthread_win32.c	/^static void WINAPI (*WakeAllConditionVariable_fn)(PCONDITION_VARIABLE) = NULL;$/;"	v	file:
WakeConditionVariable_fn	./evthread_win32.c	/^static void WINAPI (*WakeConditionVariable_fn)(PCONDITION_VARIABLE) = NULL;$/;"	v	file:
XFREE	./win32select.c	50;"	d	file:
ZERO_CHAIN	./buffer.c	/^ZERO_CHAIN(struct evbuffer *dst)$/;"	f	file:
_ARC4_LOCK	./evutil_rand.c	114;"	d	file:
_ARC4_UNLOCK	./evutil_rand.c	115;"	d	file:
_FORTIFY_SOURCE	./evdns.c	55;"	d	file:
_GNU_SOURCE	./buffer.c	38;"	d	file:
_GNU_SOURCE	./evthread_pthread.c	29;"	d	file:
_GNU_SOURCE	./evutil.c	29;"	d	file:
_GNU_SOURCE	./kqueue.c	31;"	d	file:
_URI_ADD	./http.c	4355;"	d	file:
_URI_ADD	./http.c	4409;"	d	file:
_URI_FREE_STR	./http.c	4332;"	d	file:
_URI_FREE_STR	./http.c	4345;"	d	file:
_URI_SET_STR	./http.c	4448;"	d	file:
_WIN32_IE	./evdns.c	80;"	d	file:
_WIN32_WINNT	./event_iocp.c	29;"	d	file:
_WIN32_WINNT	./evthread_win32.c	31;"	d	file:
_WIN32_WINNT	./listener.c	34;"	d	file:
__cdecl	./signal.c	87;"	d	file:
_bev_group_random_element	./bufferevent_ratelim.c	/^_bev_group_random_element(struct bufferevent_rate_limit_group *group)$/;"	f	file:
_bev_group_refill_callback	./bufferevent_ratelim.c	/^_bev_group_refill_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
_bev_group_suspend_reading	./bufferevent_ratelim.c	/^_bev_group_suspend_reading(struct bufferevent_rate_limit_group *g)$/;"	f	file:
_bev_group_suspend_writing	./bufferevent_ratelim.c	/^_bev_group_suspend_writing(struct bufferevent_rate_limit_group *g)$/;"	f	file:
_bev_group_unsuspend_reading	./bufferevent_ratelim.c	/^_bev_group_unsuspend_reading(struct bufferevent_rate_limit_group *g)$/;"	f	file:
_bev_group_unsuspend_writing	./bufferevent_ratelim.c	/^_bev_group_unsuspend_writing(struct bufferevent_rate_limit_group *g)$/;"	f	file:
_bev_refill_callback	./bufferevent_ratelim.c	/^_bev_refill_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
_bufferevent_add_event	./bufferevent.c	/^_bufferevent_add_event(struct event *ev, const struct timeval *tv)$/;"	f
_bufferevent_cancel_all	./bufferevent.c	/^_bufferevent_cancel_all(struct bufferevent *bev)$/;"	f	file:
_bufferevent_decref_and_unlock	./bufferevent.c	/^_bufferevent_decref_and_unlock(struct bufferevent *bufev)$/;"	f
_bufferevent_decrement_read_buckets	./bufferevent_ratelim.c	/^_bufferevent_decrement_read_buckets(struct bufferevent_private *bev, ev_ssize_t bytes)$/;"	f
_bufferevent_decrement_write_buckets	./bufferevent_ratelim.c	/^_bufferevent_decrement_write_buckets(struct bufferevent_private *bev, ev_ssize_t bytes)$/;"	f
_bufferevent_del_generic_timeout_cbs	./bufferevent.c	/^_bufferevent_del_generic_timeout_cbs(struct bufferevent *bev)$/;"	f
_bufferevent_generic_adj_timeouts	./bufferevent.c	/^_bufferevent_generic_adj_timeouts(struct bufferevent *bev)$/;"	f
_bufferevent_get_read_max	./bufferevent_ratelim.c	/^_bufferevent_get_read_max(struct bufferevent_private *bev)$/;"	f
_bufferevent_get_rlim_max	./bufferevent_ratelim.c	/^_bufferevent_get_rlim_max(struct bufferevent_private *bev, int is_write)$/;"	f	file:
_bufferevent_get_write_max	./bufferevent_ratelim.c	/^_bufferevent_get_write_max(struct bufferevent_private *bev)$/;"	f
_bufferevent_incref_and_lock	./bufferevent.c	/^_bufferevent_incref_and_lock(struct bufferevent *bufev)$/;"	f
_bufferevent_init_generic_timeout_cbs	./bufferevent.c	/^_bufferevent_init_generic_timeout_cbs(struct bufferevent *bev)$/;"	f
_bufferevent_run_eventcb	./bufferevent.c	/^_bufferevent_run_eventcb(struct bufferevent *bufev, short what)$/;"	f
_bufferevent_run_readcb	./bufferevent.c	/^_bufferevent_run_readcb(struct bufferevent *bufev)$/;"	f
_bufferevent_run_writecb	./bufferevent.c	/^_bufferevent_run_writecb(struct bufferevent *bufev)$/;"	f
_evbuffer_chain_pin	./buffer.c	/^_evbuffer_chain_pin(struct evbuffer_chain *chain, unsigned flag)$/;"	f
_evbuffer_chain_unpin	./buffer.c	/^_evbuffer_chain_unpin(struct evbuffer_chain *chain, unsigned flag)$/;"	f
_evbuffer_decref_and_unlock	./buffer.c	/^_evbuffer_decref_and_unlock(struct evbuffer *buffer)$/;"	f
_evbuffer_expand_fast	./buffer.c	/^_evbuffer_expand_fast(struct evbuffer *buf, size_t datlen, int n)$/;"	f
_evbuffer_incref	./buffer.c	/^_evbuffer_incref(struct evbuffer *buf)$/;"	f
_evbuffer_incref_and_lock	./buffer.c	/^_evbuffer_incref_and_lock(struct evbuffer *buf)$/;"	f
_evbuffer_overlapped_get_fd	./buffer_iocp.c	/^_evbuffer_overlapped_get_fd(struct evbuffer *buf)$/;"	f
_evbuffer_overlapped_set_fd	./buffer_iocp.c	/^_evbuffer_overlapped_set_fd(struct evbuffer *buf, evutil_socket_t fd)$/;"	f
_evbuffer_read_setup_vecs	./buffer.c	/^_evbuffer_read_setup_vecs(struct evbuffer *buf, ev_ssize_t howmuch,$/;"	f
_evbuffer_testing_use_linear_file_access	./buffer.c	/^_evbuffer_testing_use_linear_file_access(void)$/;"	f
_evbuffer_testing_use_mmap	./buffer.c	/^_evbuffer_testing_use_mmap(void)$/;"	f
_evbuffer_testing_use_sendfile	./buffer.c	/^_evbuffer_testing_use_sendfile(void)$/;"	f
_evdns_log	./evdns.c	/^_evdns_log(int warn, const char *fmt, ...)$/;"	f	file:
_evdns_nameserver_add_impl	./evdns.c	/^_evdns_nameserver_add_impl(struct evdns_base *base, const struct sockaddr *address, int addrlen) {$/;"	f	file:
_event_debug_assert_is_setup	./event.c	274;"	d	file:
_event_debug_assert_not_added	./event.c	293;"	d	file:
_event_debug_map_lock	./event.c	/^static void *_event_debug_map_lock = NULL;$/;"	v	file:
_event_debug_mode_on	./event.c	/^int _event_debug_mode_on = 0;$/;"	v
_event_debug_note_add	./event.c	232;"	d	file:
_event_debug_note_del	./event.c	253;"	d	file:
_event_debug_note_setup	./event.c	197;"	d	file:
_event_debug_note_teardown	./event.c	219;"	d	file:
_event_debugx	./log.c	/^_event_debugx(const char *fmt, ...)$/;"	f
_event_iocp_port_unlock_and_free	./event_iocp.c	/^_event_iocp_port_unlock_and_free(struct event_iocp_port *port)$/;"	f	file:
_event_strlcpy	./strlcpy.c	/^_event_strlcpy(dst, src, siz)$/;"	f
_evsig_restore_handler	./signal.c	/^_evsig_restore_handler(struct event_base *base, int evsignal)$/;"	f
_evsig_set_handler	./signal.c	/^_evsig_set_handler(struct event_base *base,$/;"	f
_evthread_cond_fns	./evthread.c	/^GLOBAL struct evthread_condition_callbacks _evthread_cond_fns = {$/;"	v	typeref:struct:evthread_condition_callbacks
_evthread_debug_get_real_lock	./evthread.c	/^_evthread_debug_get_real_lock(void *lock_)$/;"	f
_evthread_id_fn	./evthread.c	/^GLOBAL unsigned long (*_evthread_id_fn)(void) = NULL;$/;"	v
_evthread_is_debug_lock_held	./evthread.c	/^_evthread_is_debug_lock_held(void *lock_)$/;"	f
_evthread_lock_debugging_enabled	./evthread.c	/^GLOBAL int _evthread_lock_debugging_enabled = 0;$/;"	v
_evthread_lock_fns	./evthread.c	/^GLOBAL struct evthread_lock_callbacks _evthread_lock_fns = {$/;"	v	typeref:struct:evthread_lock_callbacks
_evthreadimpl_cond_alloc	./evthread.c	/^_evthreadimpl_cond_alloc(unsigned condtype)$/;"	f
_evthreadimpl_cond_free	./evthread.c	/^_evthreadimpl_cond_free(void *cond)$/;"	f
_evthreadimpl_cond_signal	./evthread.c	/^_evthreadimpl_cond_signal(void *cond, int broadcast)$/;"	f
_evthreadimpl_cond_wait	./evthread.c	/^_evthreadimpl_cond_wait(void *cond, void *lock, const struct timeval *tv)$/;"	f
_evthreadimpl_get_id	./evthread.c	/^_evthreadimpl_get_id()$/;"	f
_evthreadimpl_is_lock_debugging_enabled	./evthread.c	/^_evthreadimpl_is_lock_debugging_enabled(void)$/;"	f
_evthreadimpl_lock_alloc	./evthread.c	/^_evthreadimpl_lock_alloc(unsigned locktype)$/;"	f
_evthreadimpl_lock_free	./evthread.c	/^_evthreadimpl_lock_free(void *lock, unsigned locktype)$/;"	f
_evthreadimpl_lock_lock	./evthread.c	/^_evthreadimpl_lock_lock(unsigned mode, void *lock)$/;"	f
_evthreadimpl_lock_unlock	./evthread.c	/^_evthreadimpl_lock_unlock(unsigned mode, void *lock)$/;"	f
_evthreadimpl_locking_enabled	./evthread.c	/^_evthreadimpl_locking_enabled(void)$/;"	f
_evutil_weakrand	./evutil.c	/^_evutil_weakrand(void)$/;"	f
_mm_free_fn	./event.c	/^static void (*_mm_free_fn)(void *p) = NULL;$/;"	v	file:
_mm_malloc_fn	./event.c	/^static void *(*_mm_malloc_fn)(size_t sz) = NULL;$/;"	v	file:
_mm_realloc_fn	./event.c	/^static void *(*_mm_realloc_fn)(void *p, size_t sz) = NULL;$/;"	v	file:
_original_cond_fns	./evthread.c	/^static struct evthread_condition_callbacks _original_cond_fns = {$/;"	v	typeref:struct:evthread_condition_callbacks	file:
_original_lock_fns	./evthread.c	/^static struct evthread_lock_callbacks _original_lock_fns = {$/;"	v	typeref:struct:evthread_lock_callbacks	file:
_warn_helper	./log.c	/^_warn_helper(int severity, const char *errstr, const char *fmt, va_list ap)$/;"	f	file:
a	./evdns.c	/^		} a;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon2	file:
aaaa	./evdns.c	/^		} aaaa;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon3	file:
accept_socket_cb	./http.c	/^accept_socket_cb(struct evconnlistener *listener, evutil_socket_t nfd, struct sockaddr *peer_sa, int peer_socklen, void *arg)$/;"	f	file:
accepted_socket_cb	./listener.c	/^accepted_socket_cb(struct event_overlapped *o, ev_uintptr_t key, ev_ssize_t n, int ok)$/;"	f	file:
accepted_socket_invoke_user_cb	./listener.c	/^accepted_socket_invoke_user_cb(struct deferred_cb *dcb, void *arg)$/;"	f	file:
accepting	./listener.c	/^	struct accepting_socket **accepting;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::accepting_socket	file:
accepting_socket	./listener.c	/^struct accepting_socket {$/;"	s	file:
add_cname_to_reply	./evdns.c	/^add_cname_to_reply(struct evdns_getaddrinfo_request *data,$/;"	f	file:
added	./event.c	/^	unsigned added : 1;$/;"	m	struct:event_debug_entry	file:
additional	./evdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
addr	./evdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:
addr	./evdns.c	/^	} addr;$/;"	m	struct:hosts_entry	typeref:union:hosts_entry::__anon5	file:
addrbuf	./listener.c	/^	char addrbuf[1];$/;"	m	struct:accepting_socket	file:
addrcount	./evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon2	file:
addrcount	./evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon3	file:
address	./evdns.c	/^	struct sockaddr_storage address;$/;"	m	struct:nameserver	typeref:struct:nameserver::sockaddr_storage	file:
addresses	./evdns.c	/^			struct in6_addr addresses[MAX_V6_ADDRS];$/;"	m	struct:reply::__anon1::__anon3	typeref:struct:reply::__anon1::__anon3::in6_addr	file:
addresses	./evdns.c	/^			u32 addresses[MAX_V4_ADDRS];$/;"	m	struct:reply::__anon1::__anon2	file:
addrinfo_from_hostent	./evutil.c	/^addrinfo_from_hostent(const struct hostent *ent,$/;"	f	file:
addrlen	./evdns.c	/^	ev_socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:
addrlen	./evdns.c	/^	ev_socklen_t addrlen;$/;"	m	struct:nameserver	file:
addrlen	./evdns.c	/^	int addrlen;$/;"	m	struct:hosts_entry	file:
advance_last_with_data	./buffer.c	/^advance_last_with_data(struct evbuffer *buf)$/;"	f	file:
allow_dirty_shutdown	./bufferevent_openssl.c	/^	unsigned allow_dirty_shutdown : 1;$/;"	m	struct:bufferevent_openssl	file:
answer	./evdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
apply_numeric_port_hack	./evutil.c	/^apply_numeric_port_hack(int port, struct evutil_addrinfo **ai)$/;"	f	file:
apply_socktype_protocol_hack	./evutil.c	/^apply_socktype_protocol_hack(struct evutil_addrinfo *ai)$/;"	f	file:
arc4_addrandom	./arc4random.c	/^arc4_addrandom(const unsigned char *dat, int datlen)$/;"	f	file:
arc4_count	./arc4random.c	/^static int arc4_count;$/;"	v	file:
arc4_getbyte	./arc4random.c	/^arc4_getbyte(void)$/;"	f	file:
arc4_getword	./arc4random.c	/^arc4_getword(void)$/;"	f	file:
arc4_init	./arc4random.c	/^arc4_init(void)$/;"	f	file:
arc4_seed	./arc4random.c	/^arc4_seed(void)$/;"	f	file:
arc4_seed_proc_sys_kernel_random_uuid	./arc4random.c	/^arc4_seed_proc_sys_kernel_random_uuid(void)$/;"	f	file:
arc4_seed_sysctl_bsd	./arc4random.c	/^arc4_seed_sysctl_bsd(void)$/;"	f	file:
arc4_seed_sysctl_linux	./arc4random.c	/^arc4_seed_sysctl_linux(void)$/;"	f	file:
arc4_seed_urandom	./arc4random.c	/^arc4_seed_urandom(void)$/;"	f	file:
arc4_seed_urandom_helper_	./arc4random.c	/^static int arc4_seed_urandom_helper_(const char *fname)$/;"	f	file:
arc4_seed_win32	./arc4random.c	/^arc4_seed_win32(void)$/;"	f	file:
arc4_seeded_ok	./arc4random.c	/^static int arc4_seeded_ok;$/;"	v	file:
arc4_stir	./arc4random.c	/^arc4_stir(void)$/;"	f	file:
arc4_stir_if_needed	./arc4random.c	/^arc4_stir_if_needed(void)$/;"	f	file:
arc4_stir_pid	./arc4random.c	/^static pid_t arc4_stir_pid;$/;"	v	file:
arc4_stream	./arc4random.c	/^struct arc4_stream {$/;"	s	file:
arc4rand_lock	./evutil_rand.c	/^static void *arc4rand_lock;$/;"	v	file:
arc4random	./arc4random.c	/^arc4random(void)$/;"	f
arc4random_addrandom	./arc4random.c	/^arc4random_addrandom(const unsigned char *dat, int datlen)$/;"	f
arc4random_buf	./arc4random.c	/^arc4random_buf(void *_buf, size_t n)$/;"	f
arc4random_stir	./arc4random.c	/^arc4random_stir(void)$/;"	f
arc4random_uniform	./arc4random.c	/^arc4random_uniform(unsigned int upper_bound)$/;"	f
arc4random_urandom_filename	./arc4random.c	/^static char *arc4random_urandom_filename = NULL;$/;"	v	file:
arg	./event.c	/^	void *arg;$/;"	m	struct:event_once	file:
attr_recursive	./evthread_pthread.c	/^static pthread_mutexattr_t attr_recursive;$/;"	v	file:
authority	./evdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
base	./evdns.c	/^	struct evdns_base *base;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::evdns_base	file:
base	./evdns.c	/^	struct evdns_base *base;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_base	file:
base	./evdns.c	/^	struct evdns_base *base;$/;"	m	struct:request	typeref:struct:request::evdns_base	file:
base	./evdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:
base	./listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::evconnlistener	file:
base	./listener.c	/^	struct evconnlistener base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::evconnlistener	file:
be_async_ctrl	./bufferevent_async.c	/^be_async_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:
be_async_destruct	./bufferevent_async.c	/^be_async_destruct(struct bufferevent *bev)$/;"	f	file:
be_async_disable	./bufferevent_async.c	/^be_async_disable(struct bufferevent *bev, short what)$/;"	f	file:
be_async_enable	./bufferevent_async.c	/^be_async_enable(struct bufferevent *buf, short what)$/;"	f	file:
be_async_flush	./bufferevent_async.c	/^be_async_flush(struct bufferevent *bev, short what,$/;"	f	file:
be_async_inbuf_callback	./bufferevent_async.c	/^be_async_inbuf_callback(struct evbuffer *buf,$/;"	f	file:
be_async_outbuf_callback	./bufferevent_async.c	/^be_async_outbuf_callback(struct evbuffer *buf,$/;"	f	file:
be_filter_ctrl	./bufferevent_filter.c	/^be_filter_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:
be_filter_destruct	./bufferevent_filter.c	/^be_filter_destruct(struct bufferevent *bev)$/;"	f	file:
be_filter_disable	./bufferevent_filter.c	/^be_filter_disable(struct bufferevent *bev, short event)$/;"	f	file:
be_filter_enable	./bufferevent_filter.c	/^be_filter_enable(struct bufferevent *bev, short event)$/;"	f	file:
be_filter_eventcb	./bufferevent_filter.c	/^be_filter_eventcb(struct bufferevent *underlying, short what, void *_me)$/;"	f	file:
be_filter_flush	./bufferevent_filter.c	/^be_filter_flush(struct bufferevent *bufev,$/;"	f	file:
be_filter_process_input	./bufferevent_filter.c	/^be_filter_process_input(struct bufferevent_filtered *bevf,$/;"	f	file:
be_filter_process_output	./bufferevent_filter.c	/^be_filter_process_output(struct bufferevent_filtered *bevf,$/;"	f	file:
be_filter_readcb	./bufferevent_filter.c	/^be_filter_readcb(struct bufferevent *underlying, void *_me)$/;"	f	file:
be_filter_writecb	./bufferevent_filter.c	/^be_filter_writecb(struct bufferevent *underlying, void *_me)$/;"	f	file:
be_null_filter	./bufferevent_filter.c	/^be_null_filter(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim,$/;"	f	file:
be_openssl_adj_timeouts	./bufferevent_openssl.c	/^be_openssl_adj_timeouts(struct bufferevent *bev)$/;"	f	file:
be_openssl_ctrl	./bufferevent_openssl.c	/^be_openssl_ctrl(struct bufferevent *bev,$/;"	f	file:
be_openssl_destruct	./bufferevent_openssl.c	/^be_openssl_destruct(struct bufferevent *bev)$/;"	f	file:
be_openssl_disable	./bufferevent_openssl.c	/^be_openssl_disable(struct bufferevent *bev, short events)$/;"	f	file:
be_openssl_enable	./bufferevent_openssl.c	/^be_openssl_enable(struct bufferevent *bev, short events)$/;"	f	file:
be_openssl_eventcb	./bufferevent_openssl.c	/^be_openssl_eventcb(struct bufferevent *bev_base, short what, void *ctx)$/;"	f	file:
be_openssl_flush	./bufferevent_openssl.c	/^be_openssl_flush(struct bufferevent *bufev,$/;"	f	file:
be_openssl_handshakecb	./bufferevent_openssl.c	/^be_openssl_handshakecb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:
be_openssl_handshakeeventcb	./bufferevent_openssl.c	/^be_openssl_handshakeeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
be_openssl_outbuf_cb	./bufferevent_openssl.c	/^be_openssl_outbuf_cb(struct evbuffer *buf,$/;"	f	file:
be_openssl_readcb	./bufferevent_openssl.c	/^be_openssl_readcb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:
be_openssl_readeventcb	./bufferevent_openssl.c	/^be_openssl_readeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
be_openssl_writecb	./bufferevent_openssl.c	/^be_openssl_writecb(struct bufferevent *bev_base, void *ctx)$/;"	f	file:
be_openssl_writeeventcb	./bufferevent_openssl.c	/^be_openssl_writeeventcb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
be_pair_destruct	./bufferevent_pair.c	/^be_pair_destruct(struct bufferevent *bev)$/;"	f	file:
be_pair_disable	./bufferevent_pair.c	/^be_pair_disable(struct bufferevent *bev, short events)$/;"	f	file:
be_pair_enable	./bufferevent_pair.c	/^be_pair_enable(struct bufferevent *bufev, short events)$/;"	f	file:
be_pair_flush	./bufferevent_pair.c	/^be_pair_flush(struct bufferevent *bev, short iotype,$/;"	f	file:
be_pair_outbuf_cb	./bufferevent_pair.c	/^be_pair_outbuf_cb(struct evbuffer *outbuf,$/;"	f	file:
be_pair_transfer	./bufferevent_pair.c	/^be_pair_transfer(struct bufferevent *src, struct bufferevent *dst,$/;"	f	file:
be_pair_wants_to_talk	./bufferevent_pair.c	/^be_pair_wants_to_talk(struct bufferevent_pair *src,$/;"	f	file:
be_readbuf_full	./bufferevent_filter.c	/^be_readbuf_full(struct bufferevent_filtered *bevf,$/;"	f	file:
be_socket_add	./bufferevent_sock.c	98;"	d	file:
be_socket_adj_timeouts	./bufferevent_sock.c	/^be_socket_adj_timeouts(struct bufferevent *bufev)$/;"	f	file:
be_socket_ctrl	./bufferevent_sock.c	/^be_socket_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,$/;"	f	file:
be_socket_destruct	./bufferevent_sock.c	/^be_socket_destruct(struct bufferevent *bufev)$/;"	f	file:
be_socket_disable	./bufferevent_sock.c	/^be_socket_disable(struct bufferevent *bufev, short event)$/;"	f	file:
be_socket_enable	./bufferevent_sock.c	/^be_socket_enable(struct bufferevent *bufev, short event)$/;"	f	file:
be_socket_flush	./bufferevent_sock.c	/^be_socket_flush(struct bufferevent *bev, short iotype,$/;"	f	file:
be_socket_setfd	./bufferevent_sock.c	/^be_socket_setfd(struct bufferevent *bufev, evutil_socket_t fd)$/;"	f	file:
be_underlying_writebuf_full	./bufferevent_filter.c	/^be_underlying_writebuf_full(struct bufferevent_filtered *bevf,$/;"	f	file:
bev	./bufferevent_async.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::bufferevent_private	file:
bev	./bufferevent_filter.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent_private	file:
bev	./bufferevent_openssl.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent_private	file:
bev	./bufferevent_pair.c	/^	struct bufferevent_private bev;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_private	file:
bev_async_add_read	./bufferevent_async.c	/^bev_async_add_read(struct bufferevent_async *beva)$/;"	f	file:
bev_async_add_write	./bufferevent_async.c	/^bev_async_add_write(struct bufferevent_async *beva)$/;"	f	file:
bev_async_consider_reading	./bufferevent_async.c	/^bev_async_consider_reading(struct bufferevent_async *beva)$/;"	f	file:
bev_async_consider_writing	./bufferevent_async.c	/^bev_async_consider_writing(struct bufferevent_async *beva)$/;"	f	file:
bev_async_del_read	./bufferevent_async.c	/^bev_async_del_read(struct bufferevent_async *beva)$/;"	f	file:
bev_async_del_write	./bufferevent_async.c	/^bev_async_del_write(struct bufferevent_async *beva)$/;"	f	file:
bev_async_set_wsa_error	./bufferevent_async.c	/^bev_async_set_wsa_error(struct bufferevent *bev, struct event_overlapped *eo)$/;"	f	file:
bind_socket	./http.c	/^bind_socket(const char *address, ev_uint16_t port, int reuse)$/;"	f	file:
bind_socket_ai	./http.c	/^bind_socket_ai(struct evutil_addrinfo *ai, int reuse)$/;"	f	file:
bio_bufferevent_ctrl	./bufferevent_openssl.c	/^bio_bufferevent_ctrl(BIO *b, int cmd, long num, void *ptr)$/;"	f	file:
bio_bufferevent_free	./bufferevent_openssl.c	/^bio_bufferevent_free(BIO *b)$/;"	f	file:
bio_bufferevent_new	./bufferevent_openssl.c	/^bio_bufferevent_new(BIO *b)$/;"	f	file:
bio_bufferevent_puts	./bufferevent_openssl.c	/^bio_bufferevent_puts(BIO *b, const char *s)$/;"	f	file:
bio_bufferevent_read	./bufferevent_openssl.c	/^bio_bufferevent_read(BIO *b, char *out, int outlen)$/;"	f	file:
bio_bufferevent_write	./bufferevent_openssl.c	/^bio_bufferevent_write(BIO *b, const char *in, int inlen)$/;"	f	file:
bio_data_counts	./bufferevent_openssl.c	/^struct bio_data_counts {$/;"	s	file:
bracket_addr_ok	./http.c	/^bracket_addr_ok(const char *s, const char *eos)$/;"	f	file:
buffer	./buffer_iocp.c	/^	struct evbuffer buffer;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer	file:
bufferevent_add_to_rate_limit_group	./bufferevent_ratelim.c	/^bufferevent_add_to_rate_limit_group(struct bufferevent *bev,$/;"	f
bufferevent_async	./bufferevent_async.c	/^struct bufferevent_async {$/;"	s	file:
bufferevent_async_can_connect	./bufferevent_async.c	/^bufferevent_async_can_connect(struct bufferevent *bev)$/;"	f
bufferevent_async_connect	./bufferevent_async.c	/^bufferevent_async_connect(struct bufferevent *bev, evutil_socket_t fd,$/;"	f
bufferevent_async_new	./bufferevent_async.c	/^bufferevent_async_new(struct event_base *base,$/;"	f
bufferevent_async_set_connected	./bufferevent_async.c	/^bufferevent_async_set_connected(struct bufferevent *bev)$/;"	f
bufferevent_base_set	./bufferevent_sock.c	/^bufferevent_base_set(struct event_base *base, struct bufferevent *bufev)$/;"	f
bufferevent_connect_getaddrinfo_cb	./bufferevent_sock.c	/^bufferevent_connect_getaddrinfo_cb(int result, struct evutil_addrinfo *ai,$/;"	f	file:
bufferevent_decref	./bufferevent.c	/^bufferevent_decref(struct bufferevent *bufev)$/;"	f
bufferevent_decrement_read_limit	./bufferevent_ratelim.c	/^bufferevent_decrement_read_limit(struct bufferevent *bev, ev_ssize_t decr)$/;"	f
bufferevent_decrement_write_limit	./bufferevent_ratelim.c	/^bufferevent_decrement_write_limit(struct bufferevent *bev, ev_ssize_t decr)$/;"	f
bufferevent_disable	./bufferevent.c	/^bufferevent_disable(struct bufferevent *bufev, short event)$/;"	f
bufferevent_disable_hard	./bufferevent.c	/^bufferevent_disable_hard(struct bufferevent *bufev, short event)$/;"	f
bufferevent_enable	./bufferevent.c	/^bufferevent_enable(struct bufferevent *bufev, short event)$/;"	f
bufferevent_enable_locking	./bufferevent.c	/^bufferevent_enable_locking(struct bufferevent *bufev, void *lock)$/;"	f
bufferevent_filter_new	./bufferevent_filter.c	/^bufferevent_filter_new(struct bufferevent *underlying,$/;"	f
bufferevent_filtered	./bufferevent_filter.c	/^struct bufferevent_filtered {$/;"	s	file:
bufferevent_filtered_outbuf_cb	./bufferevent_filter.c	/^bufferevent_filtered_outbuf_cb(struct evbuffer *buf,$/;"	f	file:
bufferevent_flush	./bufferevent.c	/^bufferevent_flush(struct bufferevent *bufev,$/;"	f
bufferevent_free	./bufferevent.c	/^bufferevent_free(struct bufferevent *bufev)$/;"	f
bufferevent_generic_read_timeout_cb	./bufferevent.c	/^bufferevent_generic_read_timeout_cb(evutil_socket_t fd, short event, void *ctx)$/;"	f	file:
bufferevent_generic_write_timeout_cb	./bufferevent.c	/^bufferevent_generic_write_timeout_cb(evutil_socket_t fd, short event, void *ctx)$/;"	f	file:
bufferevent_get_base	./bufferevent.c	/^bufferevent_get_base(struct bufferevent *bufev)$/;"	f
bufferevent_get_enabled	./bufferevent.c	/^bufferevent_get_enabled(struct bufferevent *bufev)$/;"	f
bufferevent_get_input	./bufferevent.c	/^bufferevent_get_input(struct bufferevent *bufev)$/;"	f
bufferevent_get_max_to_read	./bufferevent_ratelim.c	/^bufferevent_get_max_to_read(struct bufferevent *bev)$/;"	f
bufferevent_get_max_to_write	./bufferevent_ratelim.c	/^bufferevent_get_max_to_write(struct bufferevent *bev)$/;"	f
bufferevent_get_openssl_error	./bufferevent_openssl.c	/^bufferevent_get_openssl_error(struct bufferevent *bev)$/;"	f
bufferevent_get_output	./bufferevent.c	/^bufferevent_get_output(struct bufferevent *bufev)$/;"	f
bufferevent_get_read_limit	./bufferevent_ratelim.c	/^bufferevent_get_read_limit(struct bufferevent *bev)$/;"	f
bufferevent_get_underlying	./bufferevent.c	/^bufferevent_get_underlying(struct bufferevent *bev)$/;"	f
bufferevent_get_write_limit	./bufferevent_ratelim.c	/^bufferevent_get_write_limit(struct bufferevent *bev)$/;"	f
bufferevent_getfd	./bufferevent.c	/^bufferevent_getfd(struct bufferevent *bev)$/;"	f
bufferevent_inbuf_wm_cb	./bufferevent.c	/^bufferevent_inbuf_wm_cb(struct evbuffer *buf,$/;"	f	file:
bufferevent_incref	./bufferevent.c	/^bufferevent_incref(struct bufferevent *bufev)$/;"	f
bufferevent_init_common	./bufferevent.c	/^bufferevent_init_common(struct bufferevent_private *bufev_private,$/;"	f
bufferevent_lock	./bufferevent.c	/^bufferevent_lock(struct bufferevent *bev)$/;"	f
bufferevent_new	./bufferevent_sock.c	/^bufferevent_new(evutil_socket_t fd,$/;"	f
bufferevent_openssl	./bufferevent_openssl.c	/^struct bufferevent_openssl {$/;"	s	file:
bufferevent_openssl_filter_new	./bufferevent_openssl.c	/^bufferevent_openssl_filter_new(struct event_base *base,$/;"	f
bufferevent_openssl_get_ssl	./bufferevent_openssl.c	/^bufferevent_openssl_get_ssl(struct bufferevent *bufev)$/;"	f
bufferevent_openssl_new_impl	./bufferevent_openssl.c	/^bufferevent_openssl_new_impl(struct event_base *base,$/;"	f	file:
bufferevent_openssl_socket_new	./bufferevent_openssl.c	/^bufferevent_openssl_socket_new(struct event_base *base,$/;"	f
bufferevent_ops_async	./bufferevent_async.c	/^const struct bufferevent_ops bufferevent_ops_async = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_filter	./bufferevent_filter.c	/^const struct bufferevent_ops bufferevent_ops_filter = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_openssl	./bufferevent_openssl.c	/^const struct bufferevent_ops bufferevent_ops_openssl = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_pair	./bufferevent_pair.c	/^const struct bufferevent_ops bufferevent_ops_pair = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_ops_socket	./bufferevent_sock.c	/^const struct bufferevent_ops bufferevent_ops_socket = {$/;"	v	typeref:struct:bufferevent_ops
bufferevent_pair	./bufferevent_pair.c	/^struct bufferevent_pair {$/;"	s	file:
bufferevent_pair_elt_new	./bufferevent_pair.c	/^bufferevent_pair_elt_new(struct event_base *base,$/;"	f	file:
bufferevent_pair_get_partner	./bufferevent_pair.c	/^bufferevent_pair_get_partner(struct bufferevent *bev)$/;"	f
bufferevent_pair_new	./bufferevent_pair.c	/^bufferevent_pair_new(struct event_base *base, int options,$/;"	f
bufferevent_priority_set	./bufferevent_sock.c	/^bufferevent_priority_set(struct bufferevent *bufev, int priority)$/;"	f
bufferevent_rate_limit_group_decrement_read	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_decrement_read($/;"	f
bufferevent_rate_limit_group_decrement_write	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_decrement_write($/;"	f
bufferevent_rate_limit_group_free	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_free(struct bufferevent_rate_limit_group *g)$/;"	f
bufferevent_rate_limit_group_get_read_limit	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_read_limit($/;"	f
bufferevent_rate_limit_group_get_totals	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_totals(struct bufferevent_rate_limit_group *grp,$/;"	f
bufferevent_rate_limit_group_get_write_limit	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_get_write_limit($/;"	f
bufferevent_rate_limit_group_new	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_new(struct event_base *base,$/;"	f
bufferevent_rate_limit_group_reset_totals	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_reset_totals(struct bufferevent_rate_limit_group *grp)$/;"	f
bufferevent_rate_limit_group_set_cfg	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_set_cfg($/;"	f
bufferevent_rate_limit_group_set_min_share	./bufferevent_ratelim.c	/^bufferevent_rate_limit_group_set_min_share($/;"	f
bufferevent_read	./bufferevent.c	/^bufferevent_read(struct bufferevent *bufev, void *data, size_t size)$/;"	f
bufferevent_read_buffer	./bufferevent.c	/^bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf)$/;"	f
bufferevent_readcb	./bufferevent_sock.c	/^bufferevent_readcb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
bufferevent_remove_from_rate_limit_group	./bufferevent_ratelim.c	/^bufferevent_remove_from_rate_limit_group(struct bufferevent *bev)$/;"	f
bufferevent_remove_from_rate_limit_group_internal	./bufferevent_ratelim.c	/^bufferevent_remove_from_rate_limit_group_internal(struct bufferevent *bev,$/;"	f
bufferevent_run_deferred_callbacks_locked	./bufferevent.c	/^bufferevent_run_deferred_callbacks_locked(struct deferred_cb *_, void *arg)$/;"	f	file:
bufferevent_run_deferred_callbacks_unlocked	./bufferevent.c	/^bufferevent_run_deferred_callbacks_unlocked(struct deferred_cb *_, void *arg)$/;"	f	file:
bufferevent_set_rate_limit	./bufferevent_ratelim.c	/^bufferevent_set_rate_limit(struct bufferevent *bev,$/;"	f
bufferevent_set_timeouts	./bufferevent.c	/^bufferevent_set_timeouts(struct bufferevent *bufev,$/;"	f
bufferevent_setcb	./bufferevent.c	/^bufferevent_setcb(struct bufferevent *bufev,$/;"	f
bufferevent_setfd	./bufferevent.c	/^bufferevent_setfd(struct bufferevent *bev, evutil_socket_t fd)$/;"	f
bufferevent_settimeout	./bufferevent.c	/^bufferevent_settimeout(struct bufferevent *bufev,$/;"	f
bufferevent_setwatermark	./bufferevent.c	/^bufferevent_setwatermark(struct bufferevent *bufev, short events,$/;"	f
bufferevent_socket_connect	./bufferevent_sock.c	/^bufferevent_socket_connect(struct bufferevent *bev,$/;"	f
bufferevent_socket_connect_hostname	./bufferevent_sock.c	/^bufferevent_socket_connect_hostname(struct bufferevent *bev,$/;"	f
bufferevent_socket_get_dns_error	./bufferevent_sock.c	/^bufferevent_socket_get_dns_error(struct bufferevent *bev)$/;"	f
bufferevent_socket_new	./bufferevent_sock.c	/^bufferevent_socket_new(struct event_base *base, evutil_socket_t fd,$/;"	f
bufferevent_socket_outbuf_cb	./bufferevent_sock.c	/^bufferevent_socket_outbuf_cb(struct evbuffer *buf,$/;"	f	file:
bufferevent_ssl_renegotiate	./bufferevent_openssl.c	/^bufferevent_ssl_renegotiate(struct bufferevent *bev)$/;"	f
bufferevent_suspend_read	./bufferevent.c	/^bufferevent_suspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f
bufferevent_suspend_write	./bufferevent.c	/^bufferevent_suspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f
bufferevent_unlock	./bufferevent.c	/^bufferevent_unlock(struct bufferevent *bev)$/;"	f
bufferevent_unsuspend_read	./bufferevent.c	/^bufferevent_unsuspend_read(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f
bufferevent_unsuspend_write	./bufferevent.c	/^bufferevent_unsuspend_write(struct bufferevent *bufev, bufferevent_suspend_flags what)$/;"	f
bufferevent_update_buckets	./bufferevent_ratelim.c	/^bufferevent_update_buckets(struct bufferevent_private *bev)$/;"	f	file:
bufferevent_write	./bufferevent.c	/^bufferevent_write(struct bufferevent *bufev, const void *data, size_t size)$/;"	f
bufferevent_write_buffer	./bufferevent.c	/^bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf)$/;"	f
bufferevent_writecb	./bufferevent_sock.c	/^bufferevent_writecb(evutil_socket_t fd, short event, void *arg)$/;"	f	file:
buffers	./buffer_iocp.c	/^	WSABUF buffers[MAX_WSABUFS];$/;"	m	struct:evbuffer_overlapped	file:
buflen	./listener.c	/^	ev_uint8_t buflen;$/;"	m	struct:accepting_socket	file:
bytes_to_read	./bufferevent_openssl.c	/^bytes_to_read(struct bufferevent_openssl *bev)$/;"	f	file:
cb	./event.c	/^	void (*cb)(evutil_socket_t, short, void *);$/;"	m	struct:event_once	file:
cb	./listener.c	/^	evconnlistener_cb cb;$/;"	m	struct:evconnlistener	file:
change_to_string	./epoll.c	/^change_to_string(int change)$/;"	f	file:
changes	./devpoll.c	/^	struct pollfd *changes;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:
changes	./kqueue.c	/^	struct kevent *changes;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:
changes_size	./kqueue.c	/^	int changes_size;$/;"	m	struct:kqop	file:
check_event	./evport.c	/^check_event(port_event_t* pevt)$/;"	f	file:
check_event	./evport.c	204;"	d	file:
check_evportop	./evport.c	/^check_evportop(struct evport_data *evpd)$/;"	f	file:
check_evportop	./evport.c	203;"	d	file:
check_selectop	./select.c	/^check_selectop(struct selectop *sop)$/;"	f	file:
check_selectop	./select.c	125;"	d	file:
choked	./evdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:
choked	./evdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:
class	./evdns.c	/^	u16 class; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:
clear_rbow	./bufferevent_openssl.c	/^clear_rbow(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
clear_time_cache	./event.c	/^clear_time_cache(struct event_base *base)$/;"	f	file:
clear_wbor	./bufferevent_openssl.c	/^clear_wbor(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
client_error_phrases	./http.c	/^static const char *client_error_phrases[] = {$/;"	v	file:
close	./buffer.c	2928;"	d	file:
close	./evutil.c	85;"	d	file:
closing	./evdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:
cname_result	./evdns.c	/^	char *cname_result;$/;"	m	struct:evdns_getaddrinfo_request	file:
code	./evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon7	file:
common_timeout_callback	./event.c	/^common_timeout_callback(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
common_timeout_schedule	./event.c	/^common_timeout_schedule(struct common_timeout_list *ctl,$/;"	f	file:
config_nameserver_from_reg_key	./evdns.c	/^config_nameserver_from_reg_key(struct evdns_base *base, HKEY key, const TCHAR *subkey)$/;"	f	file:
conn_closed	./bufferevent_openssl.c	/^conn_closed(struct bufferevent_openssl *bev_ssl, int errcode, int ret)$/;"	f	file:
connect_complete	./bufferevent_async.c	/^connect_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:
connect_overlapped	./bufferevent_async.c	/^	struct event_overlapped connect_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:
consider_reading	./bufferevent_openssl.c	/^consider_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
consider_writing	./bufferevent_openssl.c	/^consider_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
context	./bufferevent_filter.c	/^	void *context;$/;"	m	struct:bufferevent_filtered	file:
count	./evthread.c	/^	int count;$/;"	m	struct:debug_lock	file:
counts	./bufferevent_openssl.c	/^	struct bio_data_counts counts;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bio_data_counts	file:
current_base	./evdns.c	/^static struct evdns_base *current_base = NULL;$/;"	v	typeref:struct:evdns_base	file:
current_base	./event.c	122;"	d	file:
current_req	./evdns.c	/^	struct request *current_req;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::request	file:
data	./evdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:
data	./evdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon1	file:
datalen	./evdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:
debug_cond_wait	./evthread.c	/^debug_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:
debug_lock	./evthread.c	/^struct debug_lock {$/;"	s	file:
debug_lock_alloc	./evthread.c	/^debug_lock_alloc(unsigned locktype)$/;"	f	file:
debug_lock_free	./evthread.c	/^debug_lock_free(void *lock_, unsigned locktype)$/;"	f	file:
debug_lock_lock	./evthread.c	/^debug_lock_lock(unsigned mode, void *lock_)$/;"	f	file:
debug_lock_unlock	./evthread.c	/^debug_lock_unlock(unsigned mode, void *lock_)$/;"	f	file:
decode_int64_internal	./event_tagging.c	/^decode_int64_internal(ev_uint64_t *pnumber, struct evbuffer *evbuf, int offset)$/;"	f	file:
decode_int_internal	./event_tagging.c	/^decode_int_internal(ev_uint32_t *pnumber, struct evbuffer *evbuf, int offset)$/;"	f	file:
decode_tag_internal	./event_tagging.c	/^decode_tag_internal(ev_uint32_t *ptag, struct evbuffer *evbuf, int dodrain)$/;"	f	file:
decref_and_unlock	./bufferevent_pair.c	/^decref_and_unlock(struct bufferevent *b)$/;"	f	file:
decrement_buckets	./bufferevent_openssl.c	/^decrement_buckets(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
default_evdns_log_fn	./evdns.c	/^default_evdns_log_fn(int warning, const char *buf)$/;"	f	file:
deferred	./evdns.c	/^	struct deferred_cb deferred;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::deferred_cb	file:
deferred	./listener.c	/^	struct deferred_cb deferred;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::deferred_cb	file:
deferred_reply_callback	./evdns.c	/^struct deferred_reply_callback {$/;"	s	file:
destroy	./listener.c	/^	void (*destroy)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:
detect_monotonic	./event.c	/^detect_monotonic(void)$/;"	f	file:
devpoll_add	./devpoll.c	/^devpoll_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
devpoll_commit	./devpoll.c	/^devpoll_commit(struct devpollop *devpollop)$/;"	f	file:
devpoll_dealloc	./devpoll.c	/^devpoll_dealloc(struct event_base *base)$/;"	f	file:
devpoll_del	./devpoll.c	/^devpoll_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
devpoll_dispatch	./devpoll.c	/^devpoll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
devpoll_init	./devpoll.c	/^devpoll_init(struct event_base *base)$/;"	f	file:
devpoll_queue	./devpoll.c	/^devpoll_queue(struct devpollop *devpollop, int fd, int events) {$/;"	f	file:
devpollop	./devpoll.c	/^struct devpollop {$/;"	s	file:
devpollops	./devpoll.c	/^const struct eventop devpollops = {$/;"	v	typeref:struct:eventop
disable	./listener.c	/^	int (*disable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:
dnslabel_clear	./evdns.c	/^dnslabel_clear(struct dnslabel_table *table)$/;"	f	file:
dnslabel_entry	./evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	s	file:
dnslabel_table	./evdns.c	/^struct dnslabel_table {$/;"	s	file:
dnslabel_table_add	./evdns.c	/^dnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)$/;"	f	file:
dnslabel_table_get_pos	./evdns.c	/^dnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)$/;"	f	file:
dnslabel_table_init	./evdns.c	/^dnslabel_table_init(struct dnslabel_table *table)$/;"	f	file:
dnsname_to_labels	./evdns.c	/^dnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,$/;"	f	file:
do_fd_clear	./win32select.c	/^do_fd_clear(struct event_base *base,$/;"	f	file:
do_fd_set	./win32select.c	/^do_fd_set(struct win32op *op, struct idx_info *ent, evutil_socket_t s, int read)$/;"	f	file:
do_handshake	./bufferevent_openssl.c	/^do_handshake(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
do_read	./bufferevent_openssl.c	/^do_read(struct bufferevent_openssl *bev_ssl, int n_to_read) {$/;"	f	file:
do_write	./bufferevent_openssl.c	/^do_write(struct bufferevent_openssl *bev_ssl, int atmost)$/;"	f	file:
downcast	./bufferevent_filter.c	120;"	d	file:
downcast	./bufferevent_pair.c	64;"	d	file:
dpfd	./devpoll.c	/^	int dpfd;$/;"	m	struct:devpollop	file:
ed_fds	./evport.c	/^	struct fd_info *ed_fds;		\/* allocated fdi table		 *\/$/;"	m	struct:evport_data	typeref:struct:evport_data::fd_info	file:
ed_nevents	./evport.c	/^	int		ed_nevents;	\/* number of allocated fdi's	 *\/$/;"	m	struct:evport_data	file:
ed_pending	./evport.c	/^	int ed_pending[EVENTS_PER_GETN]; \/* fd's with pending events *\/$/;"	m	struct:evport_data	file:
ed_port	./evport.c	/^	int		ed_port;	\/* event port for system events  *\/$/;"	m	struct:evport_data	file:
enable	./listener.c	/^	int (*enable)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:
enabled	./listener.c	/^	unsigned enabled : 1;$/;"	m	struct:evconnlistener	file:
encode_int64_internal	./event_tagging.c	/^encode_int64_internal(ev_uint8_t *data, ev_uint64_t number)$/;"	f	file:
encode_int_internal	./event_tagging.c	/^encode_int_internal(ev_uint8_t *data, ev_uint32_t number)$/;"	f	file:
end_of_authority	./http.c	/^end_of_authority(char *cp)$/;"	f	file:
end_of_cpath	./http.c	4502;"	d	file:
end_of_path	./http.c	/^end_of_path(char *cp, enum uri_part part, unsigned flags)$/;"	f	file:
ent	./evmap.c	/^	} ent;$/;"	m	struct:event_map_entry	typeref:union:event_map_entry::__anon6	file:
epfd	./epoll.c	/^	int epfd;$/;"	m	struct:epollop	file:
epoll_apply_changes	./epoll.c	/^epoll_apply_changes(struct event_base *base)$/;"	f	file:
epoll_apply_one_change	./epoll.c	/^epoll_apply_one_change(struct event_base *base,$/;"	f	file:
epoll_create	./epoll_sub.c	/^epoll_create(int size)$/;"	f
epoll_ctl	./epoll_sub.c	/^epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)$/;"	f
epoll_dealloc	./epoll.c	/^epoll_dealloc(struct event_base *base)$/;"	f	file:
epoll_dispatch	./epoll.c	/^epoll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
epoll_init	./epoll.c	/^epoll_init(struct event_base *base)$/;"	f	file:
epoll_nochangelist_add	./epoll.c	/^epoll_nochangelist_add(struct event_base *base, evutil_socket_t fd,$/;"	f	file:
epoll_nochangelist_del	./epoll.c	/^epoll_nochangelist_del(struct event_base *base, evutil_socket_t fd,$/;"	f	file:
epoll_op_to_string	./epoll.c	/^epoll_op_to_string(int op)$/;"	f	file:
epoll_wait	./epoll_sub.c	/^epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)$/;"	f
epollop	./epoll.c	/^struct epollop {$/;"	s	file:
epollops	./epoll.c	/^const struct eventop epollops = {$/;"	v	typeref:struct:eventop
epollops_changelist	./epoll.c	/^static const struct eventop epollops_changelist = {$/;"	v	typeref:struct:eventop	file:
eq_debug_entry	./event.c	/^eq_debug_entry(const struct event_debug_entry *a,$/;"	f	file:
eqsocket	./evmap.c	/^eqsocket(struct event_map_entry *e1, struct event_map_entry *e2)$/;"	f	file:
err	./evdns.c	/^	u32 err;$/;"	m	struct:deferred_reply_callback	file:
error	./listener.c	/^	int error;$/;"	m	struct:accepting_socket	file:
errorcb	./listener.c	/^	evconnlistener_errorcb errorcb;$/;"	m	struct:evconnlistener	file:
errors	./bufferevent_openssl.c	/^	ev_uint32_t errors[NUM_ERRORS];$/;"	m	struct:bufferevent_openssl	file:
ev	./event.c	/^	struct event ev;$/;"	m	struct:event_once	typeref:struct:event_once::event	file:
ev_arc4random_buf	./evutil_rand.c	/^ev_arc4random_buf(void *buf, size_t n)$/;"	f	file:
ev_token_bucket_cfg_free	./bufferevent_ratelim.c	/^ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg)$/;"	f
ev_token_bucket_cfg_new	./bufferevent_ratelim.c	/^ev_token_bucket_cfg_new(size_t read_rate, size_t read_burst,$/;"	f
ev_token_bucket_get_tick	./bufferevent_ratelim.c	/^ev_token_bucket_get_tick(const struct timeval *tv,$/;"	f
ev_token_bucket_init	./bufferevent_ratelim.c	/^ev_token_bucket_init(struct ev_token_bucket *bucket,$/;"	f
ev_token_bucket_update	./bufferevent_ratelim.c	/^ev_token_bucket_update(struct ev_token_bucket *bucket,$/;"	f
evbuffer_add	./buffer.c	/^evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)$/;"	f
evbuffer_add_buffer	./buffer.c	/^evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)$/;"	f
evbuffer_add_cb	./buffer.c	/^evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)$/;"	f
evbuffer_add_file	./buffer.c	/^evbuffer_add_file(struct evbuffer *outbuf, int fd,$/;"	f
evbuffer_add_printf	./buffer.c	/^evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)$/;"	f
evbuffer_add_reference	./buffer.c	/^evbuffer_add_reference(struct evbuffer *outbuf,$/;"	f
evbuffer_add_vprintf	./buffer.c	/^evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)$/;"	f
evbuffer_cb_clear_flags	./buffer.c	/^evbuffer_cb_clear_flags(struct evbuffer *buffer,$/;"	f
evbuffer_cb_set_flags	./buffer.c	/^evbuffer_cb_set_flags(struct evbuffer *buffer,$/;"	f
evbuffer_chain_align	./buffer.c	/^evbuffer_chain_align(struct evbuffer_chain *chain)$/;"	f	file:
evbuffer_chain_free	./buffer.c	/^evbuffer_chain_free(struct evbuffer_chain *chain)$/;"	f	file:
evbuffer_chain_insert	./buffer.c	/^evbuffer_chain_insert(struct evbuffer *buf,$/;"	f	file:
evbuffer_chain_insert_new	./buffer.c	/^evbuffer_chain_insert_new(struct evbuffer *buf, size_t datlen)$/;"	f	file:
evbuffer_chain_new	./buffer.c	/^evbuffer_chain_new(size_t size)$/;"	f	file:
evbuffer_chain_should_realign	./buffer.c	/^evbuffer_chain_should_realign(struct evbuffer_chain *chain,$/;"	f	file:
evbuffer_chains_all_empty	./buffer.c	/^evbuffer_chains_all_empty(struct evbuffer_chain *chain)$/;"	f	file:
evbuffer_chains_all_empty	./buffer.c	/^static inline int evbuffer_chains_all_empty(struct evbuffer_chain *chain) {$/;"	f	file:
evbuffer_clear_flags	./buffer.c	/^evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags)$/;"	f
evbuffer_commit_read	./buffer_iocp.c	/^evbuffer_commit_read(struct evbuffer *evbuf, ev_ssize_t nBytes)$/;"	f
evbuffer_commit_space	./buffer.c	/^evbuffer_commit_space(struct evbuffer *buf,$/;"	f
evbuffer_commit_write	./buffer_iocp.c	/^evbuffer_commit_write(struct evbuffer *evbuf, ev_ssize_t nBytes)$/;"	f
evbuffer_copyout	./buffer.c	/^evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen)$/;"	f
evbuffer_defer_callbacks	./buffer.c	/^evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base)$/;"	f
evbuffer_deferred_callback	./buffer.c	/^evbuffer_deferred_callback(struct deferred_cb *cb, void *arg)$/;"	f	file:
evbuffer_drain	./buffer.c	/^evbuffer_drain(struct evbuffer *buf, size_t len)$/;"	f
evbuffer_enable_locking	./buffer.c	/^evbuffer_enable_locking(struct evbuffer *buf, void *lock)$/;"	f
evbuffer_expand	./buffer.c	/^evbuffer_expand(struct evbuffer *buf, size_t datlen)$/;"	f
evbuffer_expand_singlechain	./buffer.c	/^evbuffer_expand_singlechain(struct evbuffer *buf, size_t datlen)$/;"	f	file:
evbuffer_find	./buffer.c	/^evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len)$/;"	f
evbuffer_find_eol_char	./buffer.c	/^evbuffer_find_eol_char(struct evbuffer_ptr *it)$/;"	f	file:
evbuffer_free	./buffer.c	/^evbuffer_free(struct evbuffer *buffer)$/;"	f
evbuffer_free_all_chains	./buffer.c	/^evbuffer_free_all_chains(struct evbuffer_chain *chain)$/;"	f	file:
evbuffer_free_trailing_empty_chains	./buffer.c	/^evbuffer_free_trailing_empty_chains(struct evbuffer *buf)$/;"	f	file:
evbuffer_freeze	./buffer.c	/^evbuffer_freeze(struct evbuffer *buffer, int start)$/;"	f
evbuffer_get_contiguous_space	./buffer.c	/^evbuffer_get_contiguous_space(const struct evbuffer *buf)$/;"	f
evbuffer_get_length	./buffer.c	/^evbuffer_get_length(const struct evbuffer *buffer)$/;"	f
evbuffer_getchr	./buffer.c	/^evbuffer_getchr(struct evbuffer_ptr *it)$/;"	f	file:
evbuffer_invoke_callbacks	./buffer.c	/^evbuffer_invoke_callbacks(struct evbuffer *buffer)$/;"	f
evbuffer_launch_read	./buffer_iocp.c	/^evbuffer_launch_read(struct evbuffer *buf, size_t at_most,$/;"	f
evbuffer_launch_write	./buffer_iocp.c	/^evbuffer_launch_write(struct evbuffer *buf, ev_ssize_t at_most,$/;"	f
evbuffer_lock	./buffer.c	/^evbuffer_lock(struct evbuffer *buf)$/;"	f
evbuffer_new	./buffer.c	/^evbuffer_new(void)$/;"	f
evbuffer_overlapped	./buffer_iocp.c	/^struct evbuffer_overlapped {$/;"	s	file:
evbuffer_overlapped_new	./buffer_iocp.c	/^evbuffer_overlapped_new(evutil_socket_t fd)$/;"	f
evbuffer_peek	./buffer.c	/^evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,$/;"	f
evbuffer_prepend	./buffer.c	/^evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)$/;"	f
evbuffer_prepend_buffer	./buffer.c	/^evbuffer_prepend_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)$/;"	f
evbuffer_ptr_memcmp	./buffer.c	/^evbuffer_ptr_memcmp(const struct evbuffer *buf, const struct evbuffer_ptr *pos,$/;"	f	file:
evbuffer_ptr_set	./buffer.c	/^evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,$/;"	f
evbuffer_pullup	./buffer.c	/^evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)$/;"	f
evbuffer_read	./buffer.c	/^evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)$/;"	f
evbuffer_readfile	./buffer.c	/^evbuffer_readfile(struct evbuffer *buf, evutil_socket_t fd, ev_ssize_t howmuch)$/;"	f	file:
evbuffer_readfile	./buffer.c	151;"	d	file:
evbuffer_readline	./buffer.c	/^evbuffer_readline(struct evbuffer *buffer)$/;"	f
evbuffer_readln	./buffer.c	/^evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,$/;"	f
evbuffer_remove	./buffer.c	/^evbuffer_remove(struct evbuffer *buf, void *data_out, size_t datlen)$/;"	f
evbuffer_remove_all_callbacks	./buffer.c	/^evbuffer_remove_all_callbacks(struct evbuffer *buffer)$/;"	f	file:
evbuffer_remove_buffer	./buffer.c	/^evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,$/;"	f
evbuffer_remove_cb	./buffer.c	/^evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)$/;"	f
evbuffer_remove_cb_entry	./buffer.c	/^evbuffer_remove_cb_entry(struct evbuffer *buffer,$/;"	f
evbuffer_reserve_space	./buffer.c	/^evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,$/;"	f
evbuffer_run_callbacks	./buffer.c	/^evbuffer_run_callbacks(struct evbuffer *buffer, int running_deferred)$/;"	f	file:
evbuffer_search	./buffer.c	/^evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)$/;"	f
evbuffer_search_eol	./buffer.c	/^evbuffer_search_eol(struct evbuffer *buffer,$/;"	f
evbuffer_search_range	./buffer.c	/^evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)$/;"	f
evbuffer_set_flags	./buffer.c	/^evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags)$/;"	f
evbuffer_set_parent	./buffer.c	/^evbuffer_set_parent(struct evbuffer *buf, struct bufferevent *bev)$/;"	f
evbuffer_setcb	./buffer.c	/^evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)$/;"	f
evbuffer_strchr	./buffer.c	/^evbuffer_strchr(struct evbuffer_ptr *it, const char chr)$/;"	f	file:
evbuffer_strspn	./buffer.c	/^evbuffer_strspn($/;"	f	file:
evbuffer_unfreeze	./buffer.c	/^evbuffer_unfreeze(struct evbuffer *buffer, int start)$/;"	f
evbuffer_unlock	./buffer.c	/^evbuffer_unlock(struct evbuffer *buf)$/;"	f
evbuffer_write	./buffer.c	/^evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd)$/;"	f
evbuffer_write_atmost	./buffer.c	/^evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f
evbuffer_write_iovec	./buffer.c	/^evbuffer_write_iovec(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f	file:
evbuffer_write_sendfile	./buffer.c	/^evbuffer_write_sendfile(struct evbuffer *buffer, evutil_socket_t fd,$/;"	f	file:
evconnlistener	./listener.c	/^struct evconnlistener {$/;"	s	file:
evconnlistener_disable	./listener.c	/^evconnlistener_disable(struct evconnlistener *lev)$/;"	f
evconnlistener_enable	./listener.c	/^evconnlistener_enable(struct evconnlistener *lev)$/;"	f
evconnlistener_event	./listener.c	/^struct evconnlistener_event {$/;"	s	file:
evconnlistener_event_ops	./listener.c	/^static const struct evconnlistener_ops evconnlistener_event_ops = {$/;"	v	typeref:struct:evconnlistener_ops	file:
evconnlistener_free	./listener.c	/^evconnlistener_free(struct evconnlistener *lev)$/;"	f
evconnlistener_get_base	./listener.c	/^evconnlistener_get_base(struct evconnlistener *lev)$/;"	f
evconnlistener_get_fd	./listener.c	/^evconnlistener_get_fd(struct evconnlistener *lev)$/;"	f
evconnlistener_iocp	./listener.c	/^struct evconnlistener_iocp {$/;"	s	file:
evconnlistener_iocp_ops	./listener.c	/^static const struct evconnlistener_ops evconnlistener_iocp_ops = {$/;"	v	typeref:struct:evconnlistener_ops	file:
evconnlistener_new	./listener.c	/^evconnlistener_new(struct event_base *base,$/;"	f
evconnlistener_new_async	./listener.c	/^evconnlistener_new_async(struct event_base *base,$/;"	f
evconnlistener_new_bind	./listener.c	/^evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,$/;"	f
evconnlistener_ops	./listener.c	/^struct evconnlistener_ops {$/;"	s	file:
evconnlistener_set_cb	./listener.c	/^evconnlistener_set_cb(struct evconnlistener *lev,$/;"	f
evconnlistener_set_error_cb	./listener.c	/^evconnlistener_set_error_cb(struct evconnlistener *lev,$/;"	f
evdns_add_server_port	./evdns.c	/^evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)$/;"	f
evdns_add_server_port_with_base	./evdns.c	/^evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type cb, void *user_data)$/;"	f
evdns_base	./evdns.c	/^	struct evdns_base *evdns_base;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evdns_base	file:
evdns_base	./evdns.c	/^struct evdns_base {$/;"	s	file:
evdns_base_clear_nameservers_and_suspend	./evdns.c	/^evdns_base_clear_nameservers_and_suspend(struct evdns_base *base)$/;"	f
evdns_base_config_windows_nameservers	./evdns.c	/^evdns_base_config_windows_nameservers(struct evdns_base *base)$/;"	f
evdns_base_count_nameservers	./evdns.c	/^evdns_base_count_nameservers(struct evdns_base *base)$/;"	f
evdns_base_free	./evdns.c	/^evdns_base_free(struct evdns_base *base, int fail_requests)$/;"	f
evdns_base_free_and_unlock	./evdns.c	/^evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)$/;"	f	file:
evdns_base_load_hosts	./evdns.c	/^evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname)$/;"	f
evdns_base_load_hosts_impl	./evdns.c	/^evdns_base_load_hosts_impl(struct evdns_base *base, const char *hosts_fname)$/;"	f	file:
evdns_base_nameserver_add	./evdns.c	/^evdns_base_nameserver_add(struct evdns_base *base, unsigned long int address)$/;"	f
evdns_base_nameserver_ip_add	./evdns.c	/^evdns_base_nameserver_ip_add(struct evdns_base *base, const char *ip_as_string) {$/;"	f
evdns_base_nameserver_sockaddr_add	./evdns.c	/^evdns_base_nameserver_sockaddr_add(struct evdns_base *base,$/;"	f
evdns_base_new	./evdns.c	/^evdns_base_new(struct event_base *event_base, int initialize_nameservers)$/;"	f
evdns_base_parse_hosts_line	./evdns.c	/^evdns_base_parse_hosts_line(struct evdns_base *base, char *line)$/;"	f	file:
evdns_base_resolv_conf_parse	./evdns.c	/^evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename) {$/;"	f
evdns_base_resolv_conf_parse_impl	./evdns.c	/^evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename) {$/;"	f	file:
evdns_base_resolve_ipv4	./evdns.c	/^evdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags,$/;"	f
evdns_base_resolve_ipv6	./evdns.c	/^evdns_base_resolve_ipv6(struct evdns_base *base,$/;"	f
evdns_base_resolve_reverse	./evdns.c	/^evdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_base_resolve_reverse_ipv6	./evdns.c	/^evdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_base_resume	./evdns.c	/^evdns_base_resume(struct evdns_base *base)$/;"	f
evdns_base_search_add	./evdns.c	/^evdns_base_search_add(struct evdns_base *base, const char *domain) {$/;"	f
evdns_base_search_clear	./evdns.c	/^evdns_base_search_clear(struct evdns_base *base)$/;"	f
evdns_base_search_ndots_set	./evdns.c	/^evdns_base_search_ndots_set(struct evdns_base *base, const int ndots) {$/;"	f
evdns_base_set_max_requests_inflight	./evdns.c	/^evdns_base_set_max_requests_inflight(struct evdns_base *base, int maxinflight)$/;"	f	file:
evdns_base_set_option	./evdns.c	/^evdns_base_set_option(struct evdns_base *base,$/;"	f
evdns_base_set_option_impl	./evdns.c	/^evdns_base_set_option_impl(struct evdns_base *base,$/;"	f	file:
evdns_cancel_request	./evdns.c	/^evdns_cancel_request(struct evdns_base *base, struct evdns_request *handle)$/;"	f
evdns_clear_nameservers_and_suspend	./evdns.c	/^evdns_clear_nameservers_and_suspend(void)$/;"	f
evdns_close_server_port	./evdns.c	/^evdns_close_server_port(struct evdns_server_port *port)$/;"	f
evdns_config_windows_nameservers	./evdns.c	/^evdns_config_windows_nameservers(void)$/;"	f
evdns_count_nameservers	./evdns.c	/^evdns_count_nameservers(void)$/;"	f
evdns_err_to_getaddrinfo_err	./evdns.c	/^evdns_err_to_getaddrinfo_err(int e1)$/;"	f	file:
evdns_err_to_string	./evdns.c	/^evdns_err_to_string(int err)$/;"	f
evdns_get_default_hosts_filename	./evdns.c	/^evdns_get_default_hosts_filename(void)$/;"	f	file:
evdns_get_global_base	./evdns.c	/^evdns_get_global_base(void)$/;"	f
evdns_getaddrinfo	./evdns.c	/^evdns_getaddrinfo(struct evdns_base *dns_base,$/;"	f
evdns_getaddrinfo_cancel	./evdns.c	/^evdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *data)$/;"	f
evdns_getaddrinfo_fromhosts	./evdns.c	/^evdns_getaddrinfo_fromhosts(struct evdns_base *base,$/;"	f	file:
evdns_getaddrinfo_gotresolve	./evdns.c	/^evdns_getaddrinfo_gotresolve(int result, char type, int count,$/;"	f	file:
evdns_getaddrinfo_impl	./evutil.c	/^static evdns_getaddrinfo_fn evdns_getaddrinfo_impl = NULL;$/;"	v	file:
evdns_getaddrinfo_request	./evdns.c	/^struct evdns_getaddrinfo_request {$/;"	s	file:
evdns_getaddrinfo_set_timeout	./evdns.c	/^evdns_getaddrinfo_set_timeout(struct evdns_base *evdns_base,$/;"	f	file:
evdns_getaddrinfo_timeout_cb	./evdns.c	/^evdns_getaddrinfo_timeout_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f	file:
evdns_init	./evdns.c	/^evdns_init(void)$/;"	f
evdns_log_fn	./evdns.c	/^static evdns_debug_log_fn_type evdns_log_fn = NULL;$/;"	v	file:
evdns_nameserver_add	./evdns.c	/^evdns_nameserver_add(unsigned long int address) {$/;"	f
evdns_nameserver_free	./evdns.c	/^evdns_nameserver_free(struct nameserver *server)$/;"	f	file:
evdns_nameserver_ip_add	./evdns.c	/^evdns_nameserver_ip_add(const char *ip_as_string) {$/;"	f
evdns_nameserver_ip_add_line	./evdns.c	/^evdns_nameserver_ip_add_line(struct evdns_base *base, const char *ips) {$/;"	f	file:
evdns_request	./evdns.c	/^struct evdns_request {$/;"	s	file:
evdns_request_data_build	./evdns.c	/^evdns_request_data_build(const char *const name, const size_t name_len,$/;"	f	file:
evdns_request_insert	./evdns.c	/^evdns_request_insert(struct request *req, struct request **head) {$/;"	f	file:
evdns_request_len	./evdns.c	/^evdns_request_len(const size_t name_len) {$/;"	f	file:
evdns_request_remove	./evdns.c	/^evdns_request_remove(struct request *req, struct request **head)$/;"	f	file:
evdns_request_timeout_callback	./evdns.c	/^evdns_request_timeout_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:
evdns_request_transmit	./evdns.c	/^evdns_request_transmit(struct request *req) {$/;"	f	file:
evdns_request_transmit_to	./evdns.c	/^evdns_request_transmit_to(struct request *req, struct nameserver *server) {$/;"	f	file:
evdns_requests_pump_waiting_queue	./evdns.c	/^evdns_requests_pump_waiting_queue(struct evdns_base *base) {$/;"	f	file:
evdns_resolv_conf_parse	./evdns.c	/^evdns_resolv_conf_parse(int flags, const char *const filename) {$/;"	f
evdns_resolv_set_defaults	./evdns.c	/^evdns_resolv_set_defaults(struct evdns_base *base, int flags) {$/;"	f	file:
evdns_resolve_ipv4	./evdns.c	/^int evdns_resolve_ipv4(const char *name, int flags,$/;"	f
evdns_resolve_ipv6	./evdns.c	/^int evdns_resolve_ipv6(const char *name, int flags,$/;"	f
evdns_resolve_reverse	./evdns.c	/^int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_resolve_reverse_ipv6	./evdns.c	/^int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_result_is_answer	./evdns.c	/^evdns_result_is_answer(int result)$/;"	f	file:
evdns_resume	./evdns.c	/^evdns_resume(void)$/;"	f
evdns_search_add	./evdns.c	/^evdns_search_add(const char *domain) {$/;"	f
evdns_search_clear	./evdns.c	/^evdns_search_clear(void) {$/;"	f
evdns_search_ndots_set	./evdns.c	/^evdns_search_ndots_set(const int ndots) {$/;"	f
evdns_server_port	./evdns.c	/^struct evdns_server_port {$/;"	s	file:
evdns_server_request_add_a_reply	./evdns.c	/^evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f
evdns_server_request_add_aaaa_reply	./evdns.c	/^evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f
evdns_server_request_add_cname_reply	./evdns.c	/^evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)$/;"	f
evdns_server_request_add_ptr_reply	./evdns.c	/^evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)$/;"	f
evdns_server_request_add_reply	./evdns.c	/^evdns_server_request_add_reply(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)$/;"	f
evdns_server_request_drop	./evdns.c	/^evdns_server_request_drop(struct evdns_server_request *_req)$/;"	f
evdns_server_request_format_response	./evdns.c	/^evdns_server_request_format_response(struct server_request *req, int err)$/;"	f	file:
evdns_server_request_get_requesting_addr	./evdns.c	/^evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)$/;"	f
evdns_server_request_respond	./evdns.c	/^evdns_server_request_respond(struct evdns_server_request *_req, int err)$/;"	f
evdns_server_request_set_flags	./evdns.c	/^evdns_server_request_set_flags(struct evdns_server_request *exreq, int flags)$/;"	f
evdns_set_log_fn	./evdns.c	/^evdns_set_log_fn(evdns_debug_log_fn_type fn)$/;"	f
evdns_set_option	./evdns.c	/^evdns_set_option(const char *option, const char *val, int flags)$/;"	f
evdns_set_random_bytes_fn	./evdns.c	/^evdns_set_random_bytes_fn(void (*fn)(char *, size_t))$/;"	f
evdns_set_transaction_id_fn	./evdns.c	/^evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void))$/;"	f
evdns_shutdown	./evdns.c	/^evdns_shutdown(int fail_requests)$/;"	f
evdns_transmit	./evdns.c	/^evdns_transmit(struct evdns_base *base) {$/;"	f	file:
event	./evdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:
event	./evdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:
event	./evthread_win32.c	/^	HANDLE event;$/;"	m	struct:evthread_win32_cond	file:
event_active	./event.c	/^event_active(struct event *ev, int res, short ncalls)$/;"	f
event_active_nolock	./event.c	/^event_active_nolock(struct event *ev, int res, short ncalls)$/;"	f
event_add	./event.c	/^event_add(struct event *ev, const struct timeval *tv)$/;"	f
event_add_internal	./event.c	/^event_add_internal(struct event *ev, const struct timeval *tv,$/;"	f	file:
event_added	./listener.c	/^	unsigned event_added : 1;$/;"	m	struct:evconnlistener_iocp	file:
event_assign	./event.c	/^event_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, short events, void (*callback)(evutil_socket_t, short, void *), void *arg)$/;"	f
event_base	./evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::event_base	file:
event_base	./evdns.c	/^	struct event_base *event_base;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event_base	file:
event_base	./listener.c	/^	struct event_base *event_base;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_base	file:
event_base_add_virtual	./event.c	/^event_base_add_virtual(struct event_base *base)$/;"	f
event_base_assert_ok	./event.c	/^event_base_assert_ok(struct event_base *base)$/;"	f
event_base_del_virtual	./event.c	/^event_base_del_virtual(struct event_base *base)$/;"	f
event_base_dispatch	./event.c	/^event_base_dispatch(struct event_base *event_base)$/;"	f
event_base_dump_events	./event.c	/^event_base_dump_events(struct event_base *base, FILE *output)$/;"	f
event_base_free	./event.c	/^event_base_free(struct event_base *base)$/;"	f
event_base_get_deferred_cb_queue	./event.c	/^event_base_get_deferred_cb_queue(struct event_base *base)$/;"	f
event_base_get_features	./event.c	/^event_base_get_features(const struct event_base *base)$/;"	f
event_base_get_iocp	./event_iocp.c	/^event_base_get_iocp(struct event_base *base)$/;"	f
event_base_get_method	./event.c	/^event_base_get_method(const struct event_base *base)$/;"	f
event_base_gettimeofday_cached	./event.c	/^event_base_gettimeofday_cached(struct event_base *base, struct timeval *tv)$/;"	f
event_base_got_break	./event.c	/^event_base_got_break(struct event_base *event_base)$/;"	f
event_base_got_exit	./event.c	/^event_base_got_exit(struct event_base *event_base)$/;"	f
event_base_init_common_timeout	./event.c	/^event_base_init_common_timeout(struct event_base *base,$/;"	f
event_base_loop	./event.c	/^event_base_loop(struct event_base *base, int flags)$/;"	f
event_base_loopbreak	./event.c	/^event_base_loopbreak(struct event_base *event_base)$/;"	f
event_base_loopexit	./event.c	/^event_base_loopexit(struct event_base *event_base, const struct timeval *tv)$/;"	f
event_base_new	./event.c	/^event_base_new(void)$/;"	f
event_base_new_with_config	./event.c	/^event_base_new_with_config(const struct event_config *cfg)$/;"	f
event_base_once	./event.c	/^event_base_once(struct event_base *base, evutil_socket_t fd, short events,$/;"	f
event_base_priority_init	./event.c	/^event_base_priority_init(struct event_base *base, int npriorities)$/;"	f
event_base_set	./event.c	/^event_base_set(struct event_base *base, struct event *ev)$/;"	f
event_base_start_iocp	./event.c	/^event_base_start_iocp(struct event_base *base, int n_cpus)$/;"	f
event_base_stop_iocp	./event.c	/^event_base_stop_iocp(struct event_base *base)$/;"	f
event_change_get_fdinfo	./evmap.c	/^event_change_get_fdinfo(struct event_base *base,$/;"	f	file:
event_changelist_add	./evmap.c	/^event_changelist_add(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f
event_changelist_check	./evmap.c	/^event_changelist_check(struct event_base *base)$/;"	f	file:
event_changelist_check	./evmap.c	556;"	d	file:
event_changelist_del	./evmap.c	/^event_changelist_del(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f
event_changelist_fdinfo	./evmap.c	/^struct event_changelist_fdinfo {$/;"	s	file:
event_changelist_freemem	./evmap.c	/^event_changelist_freemem(struct event_changelist *changelist)$/;"	f
event_changelist_get_or_construct	./evmap.c	/^event_changelist_get_or_construct(struct event_changelist *changelist,$/;"	f	file:
event_changelist_grow	./evmap.c	/^event_changelist_grow(struct event_changelist *changelist)$/;"	f	file:
event_changelist_init	./evmap.c	/^event_changelist_init(struct event_changelist *changelist)$/;"	f
event_changelist_remove_all	./evmap.c	/^event_changelist_remove_all(struct event_changelist *changelist,$/;"	f
event_config_avoid_method	./event.c	/^event_config_avoid_method(struct event_config *cfg, const char *method)$/;"	f
event_config_entry_free	./event.c	/^event_config_entry_free(struct event_config_entry *entry)$/;"	f	file:
event_config_free	./event.c	/^event_config_free(struct event_config *cfg)$/;"	f
event_config_is_avoided_method	./event.c	/^event_config_is_avoided_method(const struct event_config *cfg,$/;"	f	file:
event_config_new	./event.c	/^event_config_new(void)$/;"	f
event_config_require_features	./event.c	/^event_config_require_features(struct event_config *cfg,$/;"	f
event_config_set_flag	./event.c	/^event_config_set_flag(struct event_config *cfg, int flag)$/;"	f
event_config_set_num_cpus_hint	./event.c	/^event_config_set_num_cpus_hint(struct event_config *cfg, int cpus)$/;"	f
event_count	./poll.c	/^	int event_count;		\/* Highest number alloc *\/$/;"	m	struct:pollop	file:
event_debug_entry	./event.c	/^struct event_debug_entry {$/;"	s	file:
event_debug_mode_too_late	./event.c	/^static int event_debug_mode_too_late = 0;$/;"	v	file:
event_debug_unassign	./event.c	/^event_debug_unassign(struct event *ev)$/;"	f
event_deferred_cb_cancel	./event.c	/^event_deferred_cb_cancel(struct deferred_cb_queue *queue,$/;"	f
event_deferred_cb_init	./event.c	/^event_deferred_cb_init(struct deferred_cb *cb, deferred_cb_fn fn, void *arg)$/;"	f
event_deferred_cb_queue_init	./event.c	/^event_deferred_cb_queue_init(struct deferred_cb_queue *cb)$/;"	f
event_deferred_cb_schedule	./event.c	/^event_deferred_cb_schedule(struct deferred_cb_queue *queue,$/;"	f
event_del	./event.c	/^event_del(struct event *ev)$/;"	f
event_del_internal	./event.c	/^event_del_internal(struct event *ev)$/;"	f	file:
event_dispatch	./event.c	/^event_dispatch(void)$/;"	f
event_enable_debug_mode	./event.c	/^event_enable_debug_mode(void)$/;"	f
event_err	./log.c	/^event_err(int eval, const char *fmt, ...)$/;"	f
event_errx	./log.c	/^event_errx(int eval, const char *fmt, ...)$/;"	f
event_exit	./log.c	/^event_exit(int errcode)$/;"	f	file:
event_fds	./select.c	/^	int event_fds;		\/* Highest fd in fd set *\/$/;"	m	struct:selectop	file:
event_fdsz	./select.c	/^	int event_fdsz;$/;"	m	struct:selectop	file:
event_free	./event.c	/^event_free(struct event *ev)$/;"	f
event_get_assignment	./event.c	/^event_get_assignment(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out)$/;"	f
event_get_base	./event.c	/^event_get_base(const struct event *ev)$/;"	f
event_get_callback	./event.c	/^event_get_callback(const struct event *ev)$/;"	f
event_get_callback_arg	./event.c	/^event_get_callback_arg(const struct event *ev)$/;"	f
event_get_events	./event.c	/^event_get_events(const struct event *ev)$/;"	f
event_get_fd	./event.c	/^event_get_fd(const struct event *ev)$/;"	f
event_get_method	./event.c	/^event_get_method(void)$/;"	f
event_get_struct_event_size	./event.c	/^event_get_struct_event_size(void)$/;"	f
event_get_supported_methods	./event.c	/^event_get_supported_methods(void)$/;"	f
event_get_version	./event.c	/^event_get_version(void)$/;"	f
event_get_version_number	./event.c	/^event_get_version_number(void)$/;"	f
event_get_win32_extension_fns	./event_iocp.c	/^event_get_win32_extension_fns(void)$/;"	f
event_global_current_base_	./event.c	/^struct event_base *event_global_current_base_ = NULL;$/;"	v	typeref:struct:event_base
event_global_setup_locks_	./event.c	/^event_global_setup_locks_(const int enable_locks)$/;"	f
event_haveevents	./event.c	/^event_haveevents(struct event_base *base)$/;"	f	file:
event_init	./event.c	/^event_init(void)$/;"	f
event_initialized	./event.c	/^event_initialized(const struct event *ev)$/;"	f
event_iocp_activate_overlapped	./event_iocp.c	/^event_iocp_activate_overlapped($/;"	f
event_iocp_notify_all	./event_iocp.c	/^event_iocp_notify_all(struct event_iocp_port *port)$/;"	f	file:
event_iocp_port_associate	./event_iocp.c	/^event_iocp_port_associate(struct event_iocp_port *port, evutil_socket_t fd,$/;"	f
event_iocp_port_launch	./event_iocp.c	/^event_iocp_port_launch(int n_cpus)$/;"	f
event_iocp_shutdown	./event_iocp.c	/^event_iocp_shutdown(struct event_iocp_port *port, long waitMsec)$/;"	f
event_is_method_disabled	./event.c	/^event_is_method_disabled(const char *name)$/;"	f	file:
event_listener_destroy	./listener.c	/^event_listener_destroy(struct evconnlistener *lev)$/;"	f	file:
event_listener_disable	./listener.c	/^event_listener_disable(struct evconnlistener *lev)$/;"	f	file:
event_listener_enable	./listener.c	/^event_listener_enable(struct evconnlistener *lev)$/;"	f	file:
event_listener_getbase	./listener.c	/^event_listener_getbase(struct evconnlistener *lev)$/;"	f	file:
event_listener_getfd	./listener.c	/^event_listener_getfd(struct evconnlistener *lev)$/;"	f	file:
event_log	./log.c	/^event_log(int severity, const char *msg)$/;"	f	file:
event_loop	./event.c	/^event_loop(int flags)$/;"	f
event_loopbreak	./event.c	/^event_loopbreak(void)$/;"	f
event_loopexit	./event.c	/^event_loopexit(const struct timeval *tv)$/;"	f
event_loopexit_cb	./event.c	/^event_loopexit_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
event_map_entry	./evmap.c	/^struct event_map_entry {$/;"	s	file:
event_mm_calloc_	./event.c	/^event_mm_calloc_(size_t count, size_t size)$/;"	f
event_mm_free_	./event.c	/^event_mm_free_(void *ptr)$/;"	f
event_mm_malloc_	./event.c	/^event_mm_malloc_(size_t sz)$/;"	f
event_mm_realloc_	./event.c	/^event_mm_realloc_(void *ptr, size_t sz)$/;"	f
event_mm_strdup_	./event.c	/^event_mm_strdup_(const char *str)$/;"	f
event_msgx	./log.c	/^event_msgx(const char *fmt, ...)$/;"	f
event_new	./event.c	/^event_new(struct event_base *base, evutil_socket_t fd, short events, void (*cb)(evutil_socket_t, short, void *), void *arg)$/;"	f
event_once	./event.c	/^event_once(evutil_socket_t fd, short events,$/;"	f
event_once	./event.c	/^struct event_once {$/;"	s	file:
event_once_cb	./event.c	/^event_once_cb(evutil_socket_t fd, short events, void *arg)$/;"	f	file:
event_overlapped_init	./event_iocp.c	/^event_overlapped_init(struct event_overlapped *o, iocp_callback cb)$/;"	f
event_pending	./event.c	/^event_pending(const struct event *ev, short event, struct timeval *tv)$/;"	f
event_persist_closure	./event.c	/^event_persist_closure(struct event_base *base, struct event *ev)$/;"	f	file:
event_priority_init	./event.c	/^event_priority_init(int npriorities)$/;"	f
event_priority_set	./event.c	/^event_priority_set(struct event *ev, int pri)$/;"	f
event_process_active	./event.c	/^event_process_active(struct event_base *base)$/;"	f	file:
event_process_active_single_queue	./event.c	/^event_process_active_single_queue(struct event_base *base,$/;"	f	file:
event_process_deferred_callbacks	./event.c	/^event_process_deferred_callbacks(struct deferred_cb_queue *queue, int *breakptr)$/;"	f	file:
event_queue_insert	./event.c	/^event_queue_insert(struct event_base *base, struct event *ev, int queue)$/;"	f	file:
event_queue_remove	./event.c	/^event_queue_remove(struct event_base *base, struct event *ev, int queue)$/;"	f	file:
event_readset_in	./select.c	/^	fd_set *event_readset_in;$/;"	m	struct:selectop	file:
event_readset_out	./select.c	/^	fd_set *event_readset_out;$/;"	m	struct:selectop	file:
event_reinit	./event.c	/^event_reinit(struct event_base *base)$/;"	f
event_set	./event.c	/^event_set(struct event *ev, evutil_socket_t fd, short events,$/;"	f
event_set	./poll.c	/^	struct pollfd *event_set;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:
event_set_copy	./poll.c	/^	struct pollfd *event_set_copy;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:
event_set_fatal_callback	./log.c	/^event_set_fatal_callback(event_fatal_cb cb)$/;"	f
event_set_log_callback	./log.c	/^event_set_log_callback(event_log_cb cb)$/;"	f
event_set_mem_functions	./event.c	/^event_set_mem_functions(void *(*malloc_fn)(size_t sz),$/;"	f
event_signal_closure	./event.c	/^event_signal_closure(struct event_base *base, struct event *ev)$/;"	f	file:
event_sock_err	./log.c	/^event_sock_err(int eval, evutil_socket_t sock, const char *fmt, ...)$/;"	f
event_sock_warn	./log.c	/^event_sock_warn(evutil_socket_t sock, const char *fmt, ...)$/;"	f
event_warn	./log.c	/^event_warn(const char *fmt, ...)$/;"	f
event_warnx	./log.c	/^event_warnx(const char *fmt, ...)$/;"	f
event_writeset_in	./select.c	/^	fd_set *event_writeset_in;$/;"	m	struct:selectop	file:
event_writeset_out	./select.c	/^	fd_set *event_writeset_out;$/;"	m	struct:selectop	file:
eventops	./event.c	/^static const struct eventop *eventops[] = {$/;"	v	typeref:struct:eventop	file:
events	./devpoll.c	/^	struct pollfd *events;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:
events	./epoll.c	/^	struct epoll_event *events;$/;"	m	struct:epollop	typeref:struct:epollop::epoll_event	file:
events	./evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_io	typeref:struct:evmap_io::event_list	file:
events	./evmap.c	/^	struct event_list events;$/;"	m	struct:evmap_signal	typeref:struct:evmap_signal::event_list	file:
events	./kqueue.c	/^	struct kevent *events;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:
events_size	./kqueue.c	/^	int events_size;$/;"	m	struct:kqop	file:
evhttp_accept_socket	./http.c	/^evhttp_accept_socket(struct evhttp *http, evutil_socket_t fd)$/;"	f
evhttp_accept_socket_with_handle	./http.c	/^evhttp_accept_socket_with_handle(struct evhttp *http, evutil_socket_t fd)$/;"	f
evhttp_add_event	./http.c	/^evhttp_add_event(struct event *ev, int timeout, int default_timeout)$/;"	f	file:
evhttp_add_header	./http.c	/^evhttp_add_header(struct evkeyvalq *headers,$/;"	f
evhttp_add_header_internal	./http.c	/^evhttp_add_header_internal(struct evkeyvalq *headers,$/;"	f	file:
evhttp_add_server_alias	./http.c	/^evhttp_add_server_alias(struct evhttp *http, const char *alias)$/;"	f
evhttp_add_virtual_host	./http.c	/^evhttp_add_virtual_host(struct evhttp* http, const char *pattern,$/;"	f
evhttp_append_to_last_header	./http.c	/^evhttp_append_to_last_header(struct evkeyvalq *headers, const char *line)$/;"	f	file:
evhttp_associate_new_request_with_connection	./http.c	/^evhttp_associate_new_request_with_connection(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_bind_listener	./http.c	/^evhttp_bind_listener(struct evhttp *http, struct evconnlistener *listener)$/;"	f
evhttp_bind_socket	./http.c	/^evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port)$/;"	f
evhttp_bind_socket_with_handle	./http.c	/^evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port)$/;"	f
evhttp_bound_socket_get_fd	./http.c	/^evhttp_bound_socket_get_fd(struct evhttp_bound_socket *bound)$/;"	f
evhttp_bound_socket_get_listener	./http.c	/^evhttp_bound_socket_get_listener(struct evhttp_bound_socket *bound)$/;"	f
evhttp_cancel_request	./http.c	/^evhttp_cancel_request(struct evhttp_request *req)$/;"	f
evhttp_clear_headers	./http.c	/^evhttp_clear_headers(struct evkeyvalq *headers)$/;"	f
evhttp_connected	./http.c	/^evhttp_connected(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_connection_base_new	./http.c	/^evhttp_connection_base_new(struct event_base *base, struct evdns_base *dnsbase,$/;"	f
evhttp_connection_cb	./http.c	/^evhttp_connection_cb(struct bufferevent *bufev, short what, void *arg)$/;"	f	file:
evhttp_connection_cb_cleanup	./http.c	/^evhttp_connection_cb_cleanup(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_connection_connect	./http.c	/^evhttp_connection_connect(struct evhttp_connection *evcon)$/;"	f
evhttp_connection_done	./http.c	/^evhttp_connection_done(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_connection_fail	./http.c	/^evhttp_connection_fail(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_free	./http.c	/^evhttp_connection_free(struct evhttp_connection *evcon)$/;"	f
evhttp_connection_get_base	./http.c	/^evhttp_connection_get_base(struct evhttp_connection *conn)$/;"	f
evhttp_connection_get_bufferevent	./http.c	/^evhttp_connection_get_bufferevent(struct evhttp_connection *evcon)$/;"	f
evhttp_connection_get_peer	./http.c	/^evhttp_connection_get_peer(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_incoming_fail	./http.c	/^evhttp_connection_incoming_fail(struct evhttp_request *req,$/;"	f	file:
evhttp_connection_new	./http.c	/^evhttp_connection_new(const char *address, unsigned short port)$/;"	f
evhttp_connection_reset	./http.c	/^evhttp_connection_reset(struct evhttp_connection *evcon)$/;"	f
evhttp_connection_retry	./http.c	/^evhttp_connection_retry(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
evhttp_connection_set_base	./http.c	/^evhttp_connection_set_base(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_closecb	./http.c	/^evhttp_connection_set_closecb(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_local_address	./http.c	/^evhttp_connection_set_local_address(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_local_port	./http.c	/^evhttp_connection_set_local_port(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_max_body_size	./http.c	/^evhttp_connection_set_max_body_size(struct evhttp_connection* evcon,$/;"	f
evhttp_connection_set_max_headers_size	./http.c	/^evhttp_connection_set_max_headers_size(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_retries	./http.c	/^evhttp_connection_set_retries(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_set_timeout	./http.c	/^evhttp_connection_set_timeout(struct evhttp_connection *evcon,$/;"	f
evhttp_connection_start_detectclose	./http.c	/^evhttp_connection_start_detectclose(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_connection_stop_detectclose	./http.c	/^evhttp_connection_stop_detectclose(struct evhttp_connection *evcon)$/;"	f	file:
evhttp_decode_uri	./http.c	/^evhttp_decode_uri(const char *uri)$/;"	f
evhttp_decode_uri_internal	./http.c	/^evhttp_decode_uri_internal($/;"	f	file:
evhttp_deferred_read_cb	./http.c	/^evhttp_deferred_read_cb(struct deferred_cb *cb, void *data)$/;"	f	file:
evhttp_del_accept_socket	./http.c	/^evhttp_del_accept_socket(struct evhttp *http, struct evhttp_bound_socket *bound)$/;"	f
evhttp_del_cb	./http.c	/^evhttp_del_cb(struct evhttp *http, const char *uri)$/;"	f
evhttp_dispatch_callback	./http.c	/^evhttp_dispatch_callback(struct httpcbq *callbacks, struct evhttp_request *req)$/;"	f	file:
evhttp_encode_uri	./http.c	/^evhttp_encode_uri(const char *str)$/;"	f
evhttp_error_cb	./http.c	/^evhttp_error_cb(struct bufferevent *bufev, short what, void *arg)$/;"	f	file:
evhttp_find_alias	./http.c	/^evhttp_find_alias(struct evhttp *http, struct evhttp **outhttp,$/;"	f	file:
evhttp_find_header	./http.c	/^evhttp_find_header(const struct evkeyvalq *headers, const char *key)$/;"	f
evhttp_find_vhost	./http.c	/^evhttp_find_vhost(struct evhttp *http, struct evhttp **outhttp,$/;"	f	file:
evhttp_free	./http.c	/^evhttp_free(struct evhttp* http)$/;"	f
evhttp_get_body	./http.c	/^evhttp_get_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:
evhttp_get_body_length	./http.c	/^evhttp_get_body_length(struct evhttp_request *req)$/;"	f	file:
evhttp_get_request	./http.c	/^evhttp_get_request(struct evhttp *http, evutil_socket_t fd,$/;"	f	file:
evhttp_get_request_connection	./http.c	/^evhttp_get_request_connection($/;"	f	file:
evhttp_handle_chunked_read	./http.c	/^evhttp_handle_chunked_read(struct evhttp_request *req, struct evbuffer *buf)$/;"	f	file:
evhttp_handle_request	./http.c	/^evhttp_handle_request(struct evhttp_request *req, void *arg)$/;"	f	file:
evhttp_header_is_valid_value	./http.c	/^evhttp_header_is_valid_value(const char *value)$/;"	f	file:
evhttp_htmlescape	./http.c	/^evhttp_htmlescape(const char *html)$/;"	f
evhttp_is_connection_close	./http.c	/^evhttp_is_connection_close(int flags, struct evkeyvalq* headers)$/;"	f	file:
evhttp_is_connection_keepalive	./http.c	/^evhttp_is_connection_keepalive(struct evkeyvalq* headers)$/;"	f	file:
evhttp_make_header	./http.c	/^evhttp_make_header(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:
evhttp_make_header_request	./http.c	/^evhttp_make_header_request(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_make_header_response	./http.c	/^evhttp_make_header_response(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_make_request	./http.c	/^evhttp_make_request(struct evhttp_connection *evcon,$/;"	f
evhttp_maybe_add_content_length_header	./http.c	/^evhttp_maybe_add_content_length_header(struct evkeyvalq *headers,$/;"	f	file:
evhttp_maybe_add_date_header	./http.c	/^evhttp_maybe_add_date_header(struct evkeyvalq *headers)$/;"	f	file:
evhttp_method	./http.c	/^evhttp_method(enum evhttp_cmd_type type)$/;"	f	file:
evhttp_method_may_have_body	./http.c	/^evhttp_method_may_have_body(enum evhttp_cmd_type type)$/;"	f	file:
evhttp_new	./http.c	/^evhttp_new(struct event_base *base)$/;"	f
evhttp_new_object	./http.c	/^evhttp_new_object(void)$/;"	f	file:
evhttp_parse_firstline	./http.c	/^evhttp_parse_firstline(struct evhttp_request *req, struct evbuffer *buffer)$/;"	f
evhttp_parse_headers	./http.c	/^evhttp_parse_headers(struct evhttp_request *req, struct evbuffer* buffer)$/;"	f
evhttp_parse_http_version	./http.c	/^evhttp_parse_http_version(const char *version, struct evhttp_request *req)$/;"	f	file:
evhttp_parse_query	./http.c	/^evhttp_parse_query(const char *uri, struct evkeyvalq *headers)$/;"	f
evhttp_parse_query_impl	./http.c	/^evhttp_parse_query_impl(const char *str, struct evkeyvalq *headers,$/;"	f	file:
evhttp_parse_query_str	./http.c	/^evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers)$/;"	f
evhttp_parse_request_line	./http.c	/^evhttp_parse_request_line(struct evhttp_request *req, char *line)$/;"	f	file:
evhttp_parse_response_line	./http.c	/^evhttp_parse_response_line(struct evhttp_request *req, char *line)$/;"	f	file:
evhttp_read_body	./http.c	/^evhttp_read_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:
evhttp_read_cb	./http.c	/^evhttp_read_cb(struct bufferevent *bufev, void *arg)$/;"	f	file:
evhttp_read_firstline	./http.c	/^evhttp_read_firstline(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_read_header	./http.c	/^evhttp_read_header(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_read_trailer	./http.c	/^evhttp_read_trailer(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:
evhttp_remove_header	./http.c	/^evhttp_remove_header(struct evkeyvalq *headers, const char *key)$/;"	f
evhttp_remove_server_alias	./http.c	/^evhttp_remove_server_alias(struct evhttp *http, const char *alias)$/;"	f
evhttp_remove_virtual_host	./http.c	/^evhttp_remove_virtual_host(struct evhttp* http, struct evhttp* vhost)$/;"	f
evhttp_request_dispatch	./http.c	/^evhttp_request_dispatch(struct evhttp_connection* evcon)$/;"	f	file:
evhttp_request_free	./http.c	/^evhttp_request_free(struct evhttp_request *req)$/;"	f
evhttp_request_get_command	./http.c	/^evhttp_request_get_command(const struct evhttp_request *req) {$/;"	f
evhttp_request_get_connection	./http.c	/^evhttp_request_get_connection(struct evhttp_request *req)$/;"	f
evhttp_request_get_evhttp_uri	./http.c	/^evhttp_request_get_evhttp_uri(const struct evhttp_request *req) {$/;"	f
evhttp_request_get_host	./http.c	/^evhttp_request_get_host(struct evhttp_request *req)$/;"	f
evhttp_request_get_input_buffer	./http.c	/^struct evbuffer *evhttp_request_get_input_buffer(struct evhttp_request *req)$/;"	f
evhttp_request_get_input_headers	./http.c	/^struct evkeyvalq *evhttp_request_get_input_headers(struct evhttp_request *req)$/;"	f
evhttp_request_get_output_buffer	./http.c	/^struct evbuffer *evhttp_request_get_output_buffer(struct evhttp_request *req)$/;"	f
evhttp_request_get_output_headers	./http.c	/^struct evkeyvalq *evhttp_request_get_output_headers(struct evhttp_request *req)$/;"	f
evhttp_request_get_response_code	./http.c	/^evhttp_request_get_response_code(const struct evhttp_request *req)$/;"	f
evhttp_request_get_uri	./http.c	/^evhttp_request_get_uri(const struct evhttp_request *req) {$/;"	f
evhttp_request_is_owned	./http.c	/^evhttp_request_is_owned(struct evhttp_request *req)$/;"	f
evhttp_request_new	./http.c	/^evhttp_request_new(void (*cb)(struct evhttp_request *, void *), void *arg)$/;"	f
evhttp_request_own	./http.c	/^evhttp_request_own(struct evhttp_request *req)$/;"	f
evhttp_request_set_chunked_cb	./http.c	/^evhttp_request_set_chunked_cb(struct evhttp_request *req,$/;"	f
evhttp_response_code	./http.c	/^evhttp_response_code(struct evhttp_request *req, int code, const char *reason)$/;"	f
evhttp_response_needs_body	./http.c	/^evhttp_response_needs_body(struct evhttp_request *req)$/;"	f	file:
evhttp_response_phrase_internal	./http.c	/^evhttp_response_phrase_internal(int code)$/;"	f	file:
evhttp_send	./http.c	/^evhttp_send(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	file:
evhttp_send_continue	./http.c	/^evhttp_send_continue(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_send_continue_done	./http.c	/^evhttp_send_continue_done(struct evhttp_connection *evcon, void *arg)$/;"	f	file:
evhttp_send_done	./http.c	/^evhttp_send_done(struct evhttp_connection *evcon, void *arg)$/;"	f	file:
evhttp_send_error	./http.c	/^evhttp_send_error(struct evhttp_request *req, int error, const char *reason)$/;"	f
evhttp_send_page	./http.c	/^evhttp_send_page(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f
evhttp_send_reply	./http.c	/^evhttp_send_reply(struct evhttp_request *req, int code, const char *reason,$/;"	f
evhttp_send_reply_chunk	./http.c	/^evhttp_send_reply_chunk(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f
evhttp_send_reply_end	./http.c	/^evhttp_send_reply_end(struct evhttp_request *req)$/;"	f
evhttp_send_reply_start	./http.c	/^evhttp_send_reply_start(struct evhttp_request *req, int code,$/;"	f
evhttp_set_allowed_methods	./http.c	/^evhttp_set_allowed_methods(struct evhttp* http, ev_uint16_t methods)$/;"	f
evhttp_set_cb	./http.c	/^evhttp_set_cb(struct evhttp *http, const char *uri,$/;"	f
evhttp_set_gencb	./http.c	/^evhttp_set_gencb(struct evhttp *http,$/;"	f
evhttp_set_max_body_size	./http.c	/^evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size)$/;"	f
evhttp_set_max_headers_size	./http.c	/^evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_headers_size)$/;"	f
evhttp_set_timeout	./http.c	/^evhttp_set_timeout(struct evhttp* http, int timeout_in_secs)$/;"	f
evhttp_start	./http.c	/^evhttp_start(const char *address, unsigned short port)$/;"	f
evhttp_start_read	./http.c	/^evhttp_start_read(struct evhttp_connection *evcon)$/;"	f
evhttp_uri	./http.c	/^struct evhttp_uri {$/;"	s	file:
evhttp_uri_free	./http.c	/^evhttp_uri_free(struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_fragment	./http.c	/^evhttp_uri_get_fragment(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_host	./http.c	/^evhttp_uri_get_host(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_path	./http.c	/^evhttp_uri_get_path(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_port	./http.c	/^evhttp_uri_get_port(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_query	./http.c	/^evhttp_uri_get_query(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_scheme	./http.c	/^evhttp_uri_get_scheme(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_get_userinfo	./http.c	/^evhttp_uri_get_userinfo(const struct evhttp_uri *uri)$/;"	f
evhttp_uri_join	./http.c	/^evhttp_uri_join(struct evhttp_uri *uri, char *buf, size_t limit)$/;"	f
evhttp_uri_new	./http.c	/^evhttp_uri_new(void)$/;"	f
evhttp_uri_parse	./http.c	/^evhttp_uri_parse(const char *source_uri)$/;"	f
evhttp_uri_parse_with_flags	./http.c	/^evhttp_uri_parse_with_flags(const char *source_uri, unsigned flags)$/;"	f
evhttp_uri_set_flags	./http.c	/^evhttp_uri_set_flags(struct evhttp_uri *uri, unsigned flags)$/;"	f
evhttp_uri_set_fragment	./http.c	/^evhttp_uri_set_fragment(struct evhttp_uri *uri, const char *fragment)$/;"	f
evhttp_uri_set_host	./http.c	/^evhttp_uri_set_host(struct evhttp_uri *uri, const char *host)$/;"	f
evhttp_uri_set_path	./http.c	/^evhttp_uri_set_path(struct evhttp_uri *uri, const char *path)$/;"	f
evhttp_uri_set_port	./http.c	/^evhttp_uri_set_port(struct evhttp_uri *uri, int port)$/;"	f
evhttp_uri_set_query	./http.c	/^evhttp_uri_set_query(struct evhttp_uri *uri, const char *query)$/;"	f
evhttp_uri_set_scheme	./http.c	/^evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme)$/;"	f
evhttp_uri_set_userinfo	./http.c	/^evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo)$/;"	f
evhttp_uridecode	./http.c	/^evhttp_uridecode(const char *uri, int decode_plus, size_t *size_out)$/;"	f
evhttp_uriencode	./http.c	/^evhttp_uriencode(const char *uri, ev_ssize_t len, int space_as_plus)$/;"	f
evhttp_valid_response_code	./http.c	/^evhttp_valid_response_code(int code)$/;"	f	file:
evhttp_write_buffer	./http.c	/^evhttp_write_buffer(struct evhttp_connection *evcon,$/;"	f	file:
evhttp_write_cb	./http.c	/^evhttp_write_cb(struct bufferevent *bufev, void *arg)$/;"	f	file:
evhttp_write_connectioncb	./http.c	/^evhttp_write_connectioncb(struct evhttp_connection *evcon, void *arg)$/;"	f	file:
evmap_check_integrity	./evmap.c	/^evmap_check_integrity(struct event_base *base)$/;"	f
evmap_io	./evmap.c	/^		struct evmap_io evmap_io;$/;"	m	union:event_map_entry::__anon6	typeref:struct:event_map_entry::__anon6::evmap_io	file:
evmap_io	./evmap.c	/^struct evmap_io {$/;"	s	file:
evmap_io_active	./evmap.c	/^evmap_io_active(struct event_base *base, evutil_socket_t fd, short events)$/;"	f
evmap_io_add	./evmap.c	/^evmap_io_add(struct event_base *base, evutil_socket_t fd, struct event *ev)$/;"	f
evmap_io_clear	./evmap.c	/^evmap_io_clear(struct event_io_map* ctx)$/;"	f
evmap_io_clear	./evmap.c	/^void evmap_io_clear(struct event_io_map *ctx)$/;"	f
evmap_io_del	./evmap.c	/^evmap_io_del(struct event_base *base, evutil_socket_t fd, struct event *ev)$/;"	f
evmap_io_get_fdinfo	./evmap.c	/^evmap_io_get_fdinfo(struct event_io_map *map, evutil_socket_t fd)$/;"	f
evmap_io_init	./evmap.c	/^evmap_io_init(struct evmap_io *entry)$/;"	f	file:
evmap_io_initmap	./evmap.c	/^evmap_io_initmap(struct event_io_map* ctx)$/;"	f
evmap_make_space	./evmap.c	/^evmap_make_space(struct event_signal_map *map, int slot, int msize)$/;"	f	file:
evmap_signal	./evmap.c	/^struct evmap_signal {$/;"	s	file:
evmap_signal_active	./evmap.c	/^evmap_signal_active(struct event_base *base, evutil_socket_t sig, int ncalls)$/;"	f
evmap_signal_add	./evmap.c	/^evmap_signal_add(struct event_base *base, int sig, struct event *ev)$/;"	f
evmap_signal_clear	./evmap.c	/^evmap_signal_clear(struct event_signal_map *ctx)$/;"	f
evmap_signal_del	./evmap.c	/^evmap_signal_del(struct event_base *base, int sig, struct event *ev)$/;"	f
evmap_signal_init	./evmap.c	/^evmap_signal_init(struct evmap_signal *entry)$/;"	f	file:
evmap_signal_initmap	./evmap.c	/^evmap_signal_initmap(struct event_signal_map *ctx)$/;"	f
evport_add	./evport.c	/^evport_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
evport_data	./evport.c	/^struct evport_data {$/;"	s	file:
evport_dealloc	./evport.c	/^evport_dealloc(struct event_base *base)$/;"	f	file:
evport_del	./evport.c	/^evport_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
evport_dispatch	./evport.c	/^evport_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
evport_init	./evport.c	/^evport_init(struct event_base *base)$/;"	f	file:
evportops	./evport.c	/^const struct eventop evportops = {$/;"	v	typeref:struct:eventop
evrpc_add_hook	./evrpc.c	/^evrpc_add_hook(void *vbase,$/;"	f
evrpc_construct_uri	./evrpc.c	/^evrpc_construct_uri(const char *uri)$/;"	f	file:
evrpc_free	./evrpc.c	/^evrpc_free(struct evrpc_base *base)$/;"	f
evrpc_get_reply	./evrpc.c	/^evrpc_get_reply(struct evrpc_req_generic *req)$/;"	f
evrpc_get_request	./evrpc.c	/^evrpc_get_request(struct evrpc_req_generic *req)$/;"	f
evrpc_hook_add_meta	./evrpc.c	/^evrpc_hook_add_meta(void *ctx, const char *key,$/;"	f
evrpc_hook_associate_meta	./evrpc.c	/^evrpc_hook_associate_meta(struct evrpc_hook_meta **pctx,$/;"	f	file:
evrpc_hook_context_free	./evrpc.c	/^evrpc_hook_context_free(struct evrpc_hook_meta *ctx)$/;"	f	file:
evrpc_hook_find_meta	./evrpc.c	/^evrpc_hook_find_meta(void *ctx, const char *key, void **data, size_t *data_size)$/;"	f
evrpc_hook_get_connection	./evrpc.c	/^evrpc_hook_get_connection(void *ctx)$/;"	f
evrpc_hook_meta_new	./evrpc.c	/^evrpc_hook_meta_new(void)$/;"	f	file:
evrpc_init	./evrpc.c	/^evrpc_init(struct evhttp *http_server)$/;"	f
evrpc_make_request	./evrpc.c	/^evrpc_make_request(struct evrpc_request_wrapper *ctx)$/;"	f
evrpc_make_request_ctx	./evrpc.c	/^evrpc_make_request_ctx($/;"	f
evrpc_meta_data_free	./evrpc.c	/^evrpc_meta_data_free(struct evrpc_meta_list *meta_data)$/;"	f	file:
evrpc_pause_request	./evrpc.c	/^evrpc_pause_request(void *vbase, void *ctx,$/;"	f	file:
evrpc_pool_add_connection	./evrpc.c	/^evrpc_pool_add_connection(struct evrpc_pool *pool,$/;"	f
evrpc_pool_find_connection	./evrpc.c	/^evrpc_pool_find_connection(struct evrpc_pool *pool)$/;"	f	file:
evrpc_pool_free	./evrpc.c	/^evrpc_pool_free(struct evrpc_pool *pool)$/;"	f
evrpc_pool_new	./evrpc.c	/^evrpc_pool_new(struct event_base *base)$/;"	f
evrpc_pool_remove_connection	./evrpc.c	/^evrpc_pool_remove_connection(struct evrpc_pool *pool,$/;"	f
evrpc_pool_schedule	./evrpc.c	/^evrpc_pool_schedule(struct evrpc_pool *pool)$/;"	f	file:
evrpc_pool_set_timeout	./evrpc.c	/^evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs)$/;"	f
evrpc_process_hooks	./evrpc.c	/^evrpc_process_hooks(struct evrpc_hook_list *head, void *ctx,$/;"	f	file:
evrpc_register_generic	./evrpc.c	/^evrpc_register_generic(struct evrpc_base *base, const char *name,$/;"	f
evrpc_register_object	./evrpc.c	/^evrpc_register_object(const char *name,$/;"	f	file:
evrpc_register_rpc	./evrpc.c	/^evrpc_register_rpc(struct evrpc_base *base, struct evrpc *rpc,$/;"	f
evrpc_remove_hook	./evrpc.c	/^evrpc_remove_hook(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)$/;"	f
evrpc_remove_hook_internal	./evrpc.c	/^evrpc_remove_hook_internal(struct evrpc_hook_list *head, void *handle)$/;"	f	file:
evrpc_reply_done	./evrpc.c	/^evrpc_reply_done(struct evhttp_request *req, void *arg)$/;"	f	file:
evrpc_reply_done_closure	./evrpc.c	/^evrpc_reply_done_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:
evrpc_reqstate_free	./evrpc.c	/^evrpc_reqstate_free(struct evrpc_req_generic* rpc_state)$/;"	f
evrpc_request_cb	./evrpc.c	/^evrpc_request_cb(struct evhttp_request *req, void *arg)$/;"	f	file:
evrpc_request_cb_closure	./evrpc.c	/^evrpc_request_cb_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:
evrpc_request_done	./evrpc.c	/^evrpc_request_done(struct evrpc_req_generic *rpc_state)$/;"	f
evrpc_request_done_closure	./evrpc.c	/^evrpc_request_done_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:
evrpc_request_get_pool	./evrpc.c	/^evrpc_request_get_pool(struct evrpc_request_wrapper *ctx)$/;"	f
evrpc_request_set_cb	./evrpc.c	/^evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,$/;"	f
evrpc_request_set_pool	./evrpc.c	/^evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,$/;"	f
evrpc_request_timeout	./evrpc.c	/^evrpc_request_timeout(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
evrpc_request_wrapper_free	./evrpc.c	/^evrpc_request_wrapper_free(struct evrpc_request_wrapper *request)$/;"	f	file:
evrpc_resume_request	./evrpc.c	/^evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res)$/;"	f
evrpc_schedule_request	./evrpc.c	/^evrpc_schedule_request(struct evhttp_connection *connection,$/;"	f	file:
evrpc_schedule_request_closure	./evrpc.c	/^evrpc_schedule_request_closure(void *arg, enum EVRPC_HOOK_RESULT hook_res)$/;"	f	file:
evrpc_send_request_generic	./evrpc.c	/^evrpc_send_request_generic(struct evrpc_pool *pool,$/;"	f
evrpc_unregister_rpc	./evrpc.c	/^evrpc_unregister_rpc(struct evrpc_base *base, const char *name)$/;"	f
evsig_add	./signal.c	/^evsig_add(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)$/;"	f	file:
evsig_base	./signal.c	/^static struct event_base *evsig_base = NULL;$/;"	v	typeref:struct:event_base	file:
evsig_base_fd	./signal.c	/^static evutil_socket_t evsig_base_fd = -1;$/;"	v	file:
evsig_base_lock	./signal.c	/^static void *evsig_base_lock = NULL;$/;"	v	file:
evsig_base_n_signals_added	./signal.c	/^static int evsig_base_n_signals_added = 0;$/;"	v	file:
evsig_cb	./signal.c	/^evsig_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
evsig_dealloc	./signal.c	/^evsig_dealloc(struct event_base *base)$/;"	f
evsig_del	./signal.c	/^evsig_del(struct event_base *base, evutil_socket_t evsignal, short old, short events, void *p)$/;"	f	file:
evsig_global_setup_locks_	./signal.c	/^evsig_global_setup_locks_(const int enable_locks)$/;"	f
evsig_handler	./signal.c	/^evsig_handler(int sig)$/;"	f	file:
evsig_init	./signal.c	/^evsig_init(struct event_base *base)$/;"	f
evsig_set_base	./signal.c	/^evsig_set_base(struct event_base *base)$/;"	f
evsigops	./signal.c	/^static const struct eventop evsigops = {$/;"	v	typeref:struct:eventop	file:
evtag_consume	./event_tagging.c	/^evtag_consume(struct evbuffer *evbuf)$/;"	f
evtag_decode_int	./event_tagging.c	/^evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf)$/;"	f
evtag_decode_int64	./event_tagging.c	/^evtag_decode_int64(ev_uint64_t *pnumber, struct evbuffer *evbuf)$/;"	f
evtag_decode_tag	./event_tagging.c	/^evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf)$/;"	f
evtag_encode_int	./event_tagging.c	/^evtag_encode_int(struct evbuffer *evbuf, ev_uint32_t number)$/;"	f
evtag_encode_int64	./event_tagging.c	/^evtag_encode_int64(struct evbuffer *evbuf, ev_uint64_t number)$/;"	f
evtag_encode_tag	./event_tagging.c	/^evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag)$/;"	f
evtag_init	./event_tagging.c	/^evtag_init(void)$/;"	f
evtag_marshal	./event_tagging.c	/^evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f
evtag_marshal_buffer	./event_tagging.c	/^evtag_marshal_buffer(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f
evtag_marshal_int	./event_tagging.c	/^evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)$/;"	f
evtag_marshal_int64	./event_tagging.c	/^evtag_marshal_int64(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f
evtag_marshal_string	./event_tagging.c	/^evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag, const char *string)$/;"	f
evtag_marshal_timeval	./event_tagging.c	/^evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)$/;"	f
evtag_payload_length	./event_tagging.c	/^evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f
evtag_peek	./event_tagging.c	/^evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag)$/;"	f
evtag_peek_length	./event_tagging.c	/^evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f
evtag_unmarshal	./event_tagging.c	/^evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)$/;"	f
evtag_unmarshal_fixed	./event_tagging.c	/^evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag, void *data,$/;"	f
evtag_unmarshal_header	./event_tagging.c	/^evtag_unmarshal_header(struct evbuffer *evbuf, ev_uint32_t *ptag)$/;"	f
evtag_unmarshal_int	./event_tagging.c	/^evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f
evtag_unmarshal_int64	./event_tagging.c	/^evtag_unmarshal_int64(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f
evtag_unmarshal_string	./event_tagging.c	/^evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f
evtag_unmarshal_timeval	./event_tagging.c	/^evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f
evthread_debug_lock_mark_locked	./evthread.c	/^evthread_debug_lock_mark_locked(unsigned mode, struct debug_lock *lock)$/;"	f	file:
evthread_debug_lock_mark_unlocked	./evthread.c	/^evthread_debug_lock_mark_unlocked(unsigned mode, struct debug_lock *lock)$/;"	f	file:
evthread_enable_lock_debuging	./evthread.c	/^evthread_enable_lock_debuging(void)$/;"	f
evthread_make_base_notifiable	./event.c	/^evthread_make_base_notifiable(struct event_base *base)$/;"	f
evthread_notify_base	./event.c	/^evthread_notify_base(struct event_base *base)$/;"	f	file:
evthread_notify_base_default	./event.c	/^evthread_notify_base_default(struct event_base *base)$/;"	f	file:
evthread_notify_base_eventfd	./event.c	/^evthread_notify_base_eventfd(struct event_base *base)$/;"	f	file:
evthread_notify_drain_default	./event.c	/^evthread_notify_drain_default(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
evthread_notify_drain_eventfd	./event.c	/^evthread_notify_drain_eventfd(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
evthread_posix_cond_alloc	./evthread_pthread.c	/^evthread_posix_cond_alloc(unsigned condflags)$/;"	f	file:
evthread_posix_cond_free	./evthread_pthread.c	/^evthread_posix_cond_free(void *_cond)$/;"	f	file:
evthread_posix_cond_signal	./evthread_pthread.c	/^evthread_posix_cond_signal(void *_cond, int broadcast)$/;"	f	file:
evthread_posix_cond_wait	./evthread_pthread.c	/^evthread_posix_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:
evthread_posix_get_id	./evthread_pthread.c	/^evthread_posix_get_id(void)$/;"	f	file:
evthread_posix_lock	./evthread_pthread.c	/^evthread_posix_lock(unsigned mode, void *_lock)$/;"	f	file:
evthread_posix_lock_alloc	./evthread_pthread.c	/^evthread_posix_lock_alloc(unsigned locktype)$/;"	f	file:
evthread_posix_lock_free	./evthread_pthread.c	/^evthread_posix_lock_free(void *_lock, unsigned locktype)$/;"	f	file:
evthread_posix_unlock	./evthread_pthread.c	/^evthread_posix_unlock(unsigned mode, void *_lock)$/;"	f	file:
evthread_set_condition_callbacks	./evthread.c	/^evthread_set_condition_callbacks(const struct evthread_condition_callbacks *cbs)$/;"	f
evthread_set_id_callback	./evthread.c	/^evthread_set_id_callback(unsigned long (*id_fn)(void))$/;"	f
evthread_set_lock_callbacks	./evthread.c	/^evthread_set_lock_callbacks(const struct evthread_lock_callbacks *cbs)$/;"	f
evthread_setup_global_lock_	./evthread.c	/^evthread_setup_global_lock_(void *lock_, unsigned locktype, int enable_locks)$/;"	f
evthread_use_pthreads	./evthread_pthread.c	/^evthread_use_pthreads(void)$/;"	f
evthread_use_windows_threads	./evthread_win32.c	/^evthread_use_windows_threads(void)$/;"	f
evthread_win32_cond	./evthread_win32.c	/^struct evthread_win32_cond {$/;"	s	file:
evthread_win32_cond_alloc	./evthread_win32.c	/^evthread_win32_cond_alloc(unsigned flags)$/;"	f	file:
evthread_win32_cond_free	./evthread_win32.c	/^evthread_win32_cond_free(void *_cond)$/;"	f	file:
evthread_win32_cond_signal	./evthread_win32.c	/^evthread_win32_cond_signal(void *_cond, int broadcast)$/;"	f	file:
evthread_win32_cond_wait	./evthread_win32.c	/^evthread_win32_cond_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:
evthread_win32_condvar_alloc	./evthread_win32.c	/^evthread_win32_condvar_alloc(unsigned condflags)$/;"	f	file:
evthread_win32_condvar_free	./evthread_win32.c	/^evthread_win32_condvar_free(void *_cond)$/;"	f	file:
evthread_win32_condvar_init	./evthread_win32.c	/^evthread_win32_condvar_init(void)$/;"	f	file:
evthread_win32_condvar_signal	./evthread_win32.c	/^evthread_win32_condvar_signal(void *_cond, int broadcast)$/;"	f	file:
evthread_win32_condvar_wait	./evthread_win32.c	/^evthread_win32_condvar_wait(void *_cond, void *_lock, const struct timeval *tv)$/;"	f	file:
evthread_win32_get_id	./evthread_win32.c	/^evthread_win32_get_id(void)$/;"	f	file:
evthread_win32_lock	./evthread_win32.c	/^evthread_win32_lock(unsigned mode, void *_lock)$/;"	f	file:
evthread_win32_lock_create	./evthread_win32.c	/^evthread_win32_lock_create(unsigned locktype)$/;"	f	file:
evthread_win32_lock_free	./evthread_win32.c	/^evthread_win32_lock_free(void *_lock, unsigned locktype)$/;"	f	file:
evthread_win32_unlock	./evthread_win32.c	/^evthread_win32_unlock(unsigned mode, void *_lock)$/;"	f	file:
evutil_addrinfo_append	./evutil.c	/^evutil_addrinfo_append(struct evutil_addrinfo *first,$/;"	f
evutil_adjust_hints_for_addrconfig	./evutil.c	/^evutil_adjust_hints_for_addrconfig(struct evutil_addrinfo *hints)$/;"	f
evutil_ascii_strcasecmp	./evutil.c	/^evutil_ascii_strcasecmp(const char *s1, const char *s2)$/;"	f
evutil_ascii_strncasecmp	./evutil.c	/^int evutil_ascii_strncasecmp(const char *s1, const char *s2, size_t n)$/;"	f
evutil_check_interfaces	./evutil.c	/^evutil_check_interfaces(int force_recheck)$/;"	f	file:
evutil_closesocket	./evutil.c	/^evutil_closesocket(evutil_socket_t sock)$/;"	f
evutil_ersatz_socketpair	./evutil.c	/^evutil_ersatz_socketpair(int family, int type, int protocol,$/;"	f
evutil_format_sockaddr_port	./evutil.c	/^evutil_format_sockaddr_port(const struct sockaddr *sa, char *out, size_t outlen)$/;"	f
evutil_freeaddrinfo	./evutil.c	/^evutil_freeaddrinfo(struct evutil_addrinfo *ai)$/;"	f
evutil_gai_strerror	./evutil.c	/^evutil_gai_strerror(int err)$/;"	f
evutil_getaddrinfo	./evutil.c	/^evutil_getaddrinfo(const char *nodename, const char *servname,$/;"	f
evutil_getaddrinfo_async	./evutil.c	/^evutil_getaddrinfo_async(struct evdns_base *dns_base,$/;"	f
evutil_getaddrinfo_common	./evutil.c	/^evutil_getaddrinfo_common(const char *nodename, const char *servname,$/;"	f
evutil_getaddrinfo_infer_protocols	./evutil.c	/^evutil_getaddrinfo_infer_protocols(struct evutil_addrinfo *hints)$/;"	f	file:
evutil_getenv	./evutil.c	/^evutil_getenv(const char *varname)$/;"	f
evutil_gettimeofday	./evutil.c	/^evutil_gettimeofday(struct timeval *tv, struct timezone *tz)$/;"	f
evutil_hex_char_to_int	./evutil.c	/^evutil_hex_char_to_int(char c)$/;"	f
evutil_inet_ntop	./evutil.c	/^evutil_inet_ntop(int af, const void *src, char *dst, size_t len)$/;"	f
evutil_inet_pton	./evutil.c	/^evutil_inet_pton(int af, const char *src, void *dst)$/;"	f
evutil_issetugid	./evutil.c	/^evutil_issetugid(void)$/;"	f	file:
evutil_load_windows_system_library	./evutil.c	/^evutil_load_windows_system_library(const TCHAR *library_name)$/;"	f
evutil_make_listen_socket_reuseable	./evutil.c	/^evutil_make_listen_socket_reuseable(evutil_socket_t sock)$/;"	f
evutil_make_socket_closeonexec	./evutil.c	/^evutil_make_socket_closeonexec(evutil_socket_t fd)$/;"	f
evutil_make_socket_nonblocking	./evutil.c	/^evutil_make_socket_nonblocking(evutil_socket_t fd)$/;"	f
evutil_memclear_	./evutil.c	/^evutil_memclear_(void *mem, size_t len)$/;"	f
evutil_memset_volatile_	./evutil.c	/^void * (*volatile evutil_memset_volatile_)(void *, int, size_t) = memset;$/;"	v
evutil_new_addrinfo	./evutil.c	/^evutil_new_addrinfo(struct sockaddr *sa, ev_socklen_t socklen,$/;"	f
evutil_open_closeonexec	./evutil.c	/^evutil_open_closeonexec(const char *pathname, int flags, unsigned mode)$/;"	f
evutil_parse_servname	./evutil.c	/^evutil_parse_servname(const char *servname, const char *protocol,$/;"	f	file:
evutil_parse_sockaddr_port	./evutil.c	/^evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)$/;"	f
evutil_read_file	./evutil.c	/^evutil_read_file(const char *filename, char **content_out, size_t *len_out,$/;"	f
evutil_secure_rng_add_bytes	./evutil_rand.c	/^evutil_secure_rng_add_bytes(const char *buf, size_t n)$/;"	f
evutil_secure_rng_get_bytes	./evutil_rand.c	/^evutil_secure_rng_get_bytes(void *buf, size_t n)$/;"	f
evutil_secure_rng_global_setup_locks_	./evutil_rand.c	/^evutil_secure_rng_global_setup_locks_(const int enable_locks)$/;"	f
evutil_secure_rng_init	./evutil_rand.c	/^evutil_secure_rng_init(void)$/;"	f
evutil_secure_rng_set_urandom_device_file	./evutil_rand.c	/^evutil_secure_rng_set_urandom_device_file(char *fname)$/;"	f
evutil_set_evdns_getaddrinfo_fn	./evutil.c	/^evutil_set_evdns_getaddrinfo_fn(evdns_getaddrinfo_fn fn)$/;"	f
evutil_snprintf	./evutil.c	/^evutil_snprintf(char *buf, size_t buflen, const char *format, ...)$/;"	f
evutil_sockaddr_cmp	./evutil.c	/^evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,$/;"	f
evutil_sockaddr_is_loopback	./evutil.c	/^evutil_sockaddr_is_loopback(const struct sockaddr *addr)$/;"	f
evutil_socket_connect	./evutil.c	/^evutil_socket_connect(evutil_socket_t *fd_ptr, struct sockaddr *sa, int socklen)$/;"	f
evutil_socket_error_to_string	./evutil.c	/^evutil_socket_error_to_string(int errcode)$/;"	f
evutil_socket_finished_connecting	./evutil.c	/^evutil_socket_finished_connecting(evutil_socket_t fd)$/;"	f
evutil_socket_geterror	./evutil.c	/^evutil_socket_geterror(evutil_socket_t sock)$/;"	f
evutil_socketpair	./evutil.c	/^evutil_socketpair(int family, int type, int protocol, evutil_socket_t fd[2])$/;"	f
evutil_strtoll	./evutil.c	/^evutil_strtoll(const char *s, char **endptr, int base)$/;"	f
evutil_tv_to_msec	./evutil.c	/^evutil_tv_to_msec(const struct timeval *tv)$/;"	f
evutil_unparse_protoname	./evutil.c	/^evutil_unparse_protoname(int proto)$/;"	f	file:
evutil_vsnprintf	./evutil.c	/^evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)$/;"	f
exset_out	./win32select.c	/^	struct win_fd_set *exset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:
extension_fns_initialized	./event_iocp.c	/^static int extension_fns_initialized = 0;$/;"	v	file:
failed_times	./evdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:
fake_getnameinfo	./http.c	/^fake_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,$/;"	f	file:
family	./listener.c	/^	ev_uint8_t family;$/;"	m	struct:accepting_socket	file:
fatal_fn	./log.c	/^static event_fatal_cb fatal_fn = NULL;$/;"	v	file:
fd	./buffer_iocp.c	/^	evutil_socket_t fd;$/;"	m	struct:evbuffer_overlapped	file:
fd	./evmap.c	/^	evutil_socket_t fd;$/;"	m	struct:event_map_entry	file:
fd	./listener.c	/^	evutil_socket_t fd;$/;"	m	struct:evconnlistener_iocp	file:
fd_array	./win32select.c	/^	SOCKET fd_array[1];$/;"	m	struct:win_fd_set	file:
fd_count	./win32select.c	/^	u_int fd_count;$/;"	m	struct:win_fd_set	file:
fd_info	./evport.c	/^struct fd_info {$/;"	s	file:
fd_is_set	./bufferevent_openssl.c	/^	unsigned fd_is_set : 1;$/;"	m	struct:bufferevent_openssl	file:
fd_mask	./select.c	/^typedef unsigned long fd_mask;$/;"	t	file:
fd_set_copy	./win32select.c	/^fd_set_copy(struct win_fd_set *out, const struct win_fd_set *in)$/;"	f	file:
fdi_what	./evport.c	/^	short fdi_what;		\/* combinations of EV_READ and EV_WRITE *\/$/;"	m	struct:fd_info	file:
find_eol_char	./buffer.c	/^find_eol_char(char *s, size_t len)$/;"	f	file:
find_hosts_entry	./evdns.c	/^find_hosts_entry(struct evdns_base *base, const char *hostname,$/;"	f	file:
first_pinned	./buffer_iocp.c	/^	struct evbuffer_chain *first_pinned;$/;"	m	struct:evbuffer_overlapped	typeref:struct:evbuffer_overlapped::evbuffer_chain	file:
flags	./http.c	/^	unsigned flags;$/;"	m	struct:evhttp_uri	file:
flags	./listener.c	/^	unsigned flags;$/;"	m	struct:evconnlistener	file:
fragment	./http.c	/^	char *fragment; \/* fragment or NULL *\/$/;"	m	struct:evhttp_uri	file:
free_and_unlock_accepting_socket	./listener.c	/^free_and_unlock_accepting_socket(struct accepting_socket *as)$/;"	f	file:
free_context	./bufferevent_filter.c	/^	void (*free_context)(void *);$/;"	m	struct:bufferevent_filtered	file:
free_getaddrinfo_request	./evdns.c	/^free_getaddrinfo_request(struct evdns_getaddrinfo_request *data)$/;"	f	file:
free_on_cb	./listener.c	/^	unsigned free_on_cb:1;$/;"	m	struct:accepting_socket	file:
fstat	./evutil.c	86;"	d	file:
generation	./evthread_win32.c	/^	int generation;$/;"	m	struct:evthread_win32_cond	file:
get_common_timeout_list	./event.c	/^get_common_timeout_list(struct event_base *base, const struct timeval *tv)$/;"	f	file:
get_deferred_queue	./http.c	1036;"	d	file:
get_extension_function	./event_iocp.c	/^get_extension_function(SOCKET s, const GUID *which_fn)$/;"	f	file:
get_n_bytes_readable_on_socket	./buffer.c	/^get_n_bytes_readable_on_socket(evutil_socket_t fd)$/;"	f	file:
getaddrinfo_ipv4_answered	./evdns.c	/^	int getaddrinfo_ipv4_answered;$/;"	m	struct:evdns_base	file:
getaddrinfo_ipv4_timeouts	./evdns.c	/^	int getaddrinfo_ipv4_timeouts;$/;"	m	struct:evdns_base	file:
getaddrinfo_ipv6_answered	./evdns.c	/^	int getaddrinfo_ipv6_answered;$/;"	m	struct:evdns_base	file:
getaddrinfo_ipv6_timeouts	./evdns.c	/^	int getaddrinfo_ipv6_timeouts;$/;"	m	struct:evdns_base	file:
getaddrinfo_merge_err	./evdns.c	/^getaddrinfo_merge_err(int e1, int e2)$/;"	f	file:
getaddrinfo_subrequest	./evdns.c	/^struct getaddrinfo_subrequest {$/;"	s	file:
getbase	./listener.c	/^	struct event_base *(*getbase)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	typeref:struct:evconnlistener_ops::getbase	file:
getfd	./listener.c	/^	evutil_socket_t (*getfd)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:
getpid	./arc4random.c	83;"	d	file:
gettime	./event.c	/^gettime(struct event_base *base, struct timeval *tp)$/;"	f	file:
global_getaddrinfo_allow_skew	./evdns.c	/^	struct timeval global_getaddrinfo_allow_skew;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:
global_good_nameservers	./evdns.c	/^	int global_good_nameservers;$/;"	m	struct:evdns_base	file:
global_max_nameserver_timeout	./evdns.c	/^	int global_max_nameserver_timeout;$/;"	m	struct:evdns_base	file:
global_max_reissues	./evdns.c	/^	int global_max_reissues;  \/* a reissue occurs when we get some errors from the server *\/$/;"	m	struct:evdns_base	file:
global_max_requests_inflight	./evdns.c	/^	int global_max_requests_inflight;$/;"	m	struct:evdns_base	file:
global_max_retransmits	./evdns.c	/^	int global_max_retransmits;  \/* number of times we'll retransmit a request which timed out *\/$/;"	m	struct:evdns_base	file:
global_nameserver_probe_initial_timeout	./evdns.c	/^	struct timeval global_nameserver_probe_initial_timeout;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:
global_outgoing_address	./evdns.c	/^	struct sockaddr_storage global_outgoing_address;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::sockaddr_storage	file:
global_outgoing_addrlen	./evdns.c	/^	ev_socklen_t global_outgoing_addrlen;$/;"	m	struct:evdns_base	file:
global_randomize_case	./evdns.c	/^	int global_randomize_case;$/;"	m	struct:evdns_base	file:
global_requests_inflight	./evdns.c	/^	int global_requests_inflight;$/;"	m	struct:evdns_base	file:
global_requests_waiting	./evdns.c	/^	int global_requests_waiting;$/;"	m	struct:evdns_base	file:
global_search_state	./evdns.c	/^	struct search_state *global_search_state;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::search_state	file:
global_timeout	./evdns.c	/^	struct timeval global_timeout;	\/* 5 seconds by default *\/$/;"	m	struct:evdns_base	typeref:struct:evdns_base::timeval	file:
got_eof	./bufferevent_filter.c	/^	unsigned got_eof;$/;"	m	struct:bufferevent_filtered	file:
grow	./evport.c	/^grow(struct evport_data *epdp, int factor)$/;"	f	file:
grow_fd_sets	./win32select.c	/^grow_fd_sets(struct win32op *op, unsigned new_num_fds)$/;"	f	file:
had_ipv4_address	./evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
had_ipv6_address	./evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
handle	./evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::evdns_request	file:
handle	./evdns.c	/^	struct evdns_request *handle;$/;"	m	struct:request	typeref:struct:request::evdns_request	file:
handle_entry	./event_iocp.c	/^handle_entry(OVERLAPPED *o, ULONG_PTR completion_key, DWORD nBytes, int ok)$/;"	f	file:
hash_debug_entry	./event.c	/^hash_debug_entry(const struct event_debug_entry *e)$/;"	f	file:
hashsocket	./evmap.c	/^hashsocket(struct event_map_entry *e)$/;"	f	file:
have_answer	./evdns.c	/^	unsigned int have_answer : 1;$/;"	m	struct:reply	file:
have_checked_interfaces	./evutil.c	/^static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;$/;"	v	file:
have_reply	./evdns.c	/^	u8 have_reply;$/;"	m	struct:deferred_reply_callback	file:
head	./evdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:
held_by	./evthread.c	/^	unsigned long held_by;$/;"	m	struct:debug_lock	file:
hints	./evdns.c	/^	struct evutil_addrinfo hints;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:
host	./http.c	/^	char *host; \/* hostname, IP address, or NULL *\/$/;"	m	struct:evhttp_uri	file:
hostname	./evdns.c	/^	char hostname[1];$/;"	m	struct:hosts_entry	file:
hosts_entry	./evdns.c	/^struct hosts_entry {$/;"	s	file:
html_replace	./http.c	/^html_replace(const char ch, const char **escaped)$/;"	f	file:
i	./arc4random.c	/^	unsigned char i;$/;"	m	struct:arc4_stream	file:
idx_info	./win32select.c	/^struct idx_info {$/;"	s	file:
idxplus1	./evmap.c	/^	int idxplus1; \/* this is the index +1, so that memset(0) will make it$/;"	m	struct:event_changelist_fdinfo	file:
idxplus1	./poll.c	/^	int idxplus1;$/;"	m	struct:pollidx	file:
incref_and_lock	./bufferevent_pair.c	/^incref_and_lock(struct bufferevent *b)$/;"	f	file:
informational_phrases	./http.c	/^static const char *informational_phrases[] = {$/;"	v	file:
init_bio_counts	./bufferevent_openssl.c	/^init_bio_counts(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
init_extension_functions	./event_iocp.c	/^init_extension_functions(struct win32_extension_fns *ext)$/;"	f	file:
insert_common_timeout_inorder	./event.c	/^insert_common_timeout_inorder(struct common_timeout_list *ctl,$/;"	f	file:
iocp_listener_destroy	./listener.c	/^iocp_listener_destroy(struct evconnlistener *lev)$/;"	f	file:
iocp_listener_disable	./listener.c	/^iocp_listener_disable(struct evconnlistener *lev)$/;"	f	file:
iocp_listener_disable_impl	./listener.c	/^iocp_listener_disable_impl(struct evconnlistener *lev, int shutdown)$/;"	f	file:
iocp_listener_enable	./listener.c	/^iocp_listener_enable(struct evconnlistener *lev)$/;"	f	file:
iocp_listener_event_add	./listener.c	/^iocp_listener_event_add(struct evconnlistener_iocp *lev)$/;"	f	file:
iocp_listener_event_del	./listener.c	/^iocp_listener_event_del(struct evconnlistener_iocp *lev)$/;"	f	file:
iocp_listener_getbase	./listener.c	/^iocp_listener_getbase(struct evconnlistener *lev)$/;"	f	file:
iocp_listener_getfd	./listener.c	/^iocp_listener_getfd(struct evconnlistener *lev)$/;"	f	file:
ipv4_request	./evdns.c	/^	struct getaddrinfo_subrequest ipv4_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:
ipv6_request	./evdns.c	/^	struct getaddrinfo_subrequest ipv6_request;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::getaddrinfo_subrequest	file:
is_common_timeout	./event.c	/^is_common_timeout(const struct timeval *tv,$/;"	f	file:
is_name	./evdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:
is_same_common_timeout	./event.c	/^is_same_common_timeout(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	file:
j	./arc4random.c	/^	unsigned char j;$/;"	m	struct:arc4_stream	file:
kq	./kqueue.c	/^	int kq;$/;"	m	struct:kqop	file:
kq_build_changes_list	./kqueue.c	/^kq_build_changes_list(const struct event_changelist *changelist,$/;"	f	file:
kq_dealloc	./kqueue.c	/^kq_dealloc(struct event_base *base)$/;"	f	file:
kq_dispatch	./kqueue.c	/^kq_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
kq_grow_events	./kqueue.c	/^kq_grow_events(struct kqop *kqop, size_t new_size)$/;"	f	file:
kq_init	./kqueue.c	/^kq_init(struct event_base *base)$/;"	f	file:
kq_setup_kevent	./kqueue.c	/^kq_setup_kevent(struct kevent *out, evutil_socket_t fd, int filter, short change)$/;"	f	file:
kq_sig_add	./kqueue.c	/^kq_sig_add(struct event_base *base, int nsignal, short old, short events, void *p)$/;"	f	file:
kq_sig_del	./kqueue.c	/^kq_sig_del(struct event_base *base, int nsignal, short old, short events, void *p)$/;"	f	file:
kq_sighandler	./kqueue.c	/^kq_sighandler(int sig)$/;"	f	file:
kqop	./kqueue.c	/^struct kqop {$/;"	s	file:
kqop_free	./kqueue.c	/^kqop_free(struct kqop *kqop)$/;"	f	file:
kqops	./kqueue.c	/^const struct eventop kqops = {$/;"	v	typeref:struct:eventop
kqsigops	./kqueue.c	/^static const struct eventop kqsigops = {$/;"	v	typeref:struct:eventop	file:
labels	./evdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:
last_write	./bufferevent_openssl.c	/^	ev_ssize_t last_write;$/;"	m	struct:bufferevent_openssl	file:
len	./evdns.c	/^	int len;$/;"	m	struct:search_domain	file:
lev	./listener.c	/^	struct evconnlistener_iocp *lev;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::evconnlistener_iocp	file:
listener	./listener.c	/^	struct event listener;$/;"	m	struct:evconnlistener_event	typeref:struct:evconnlistener_event::event	file:
listener_decref_and_unlock	./listener.c	/^listener_decref_and_unlock(struct evconnlistener *listener)$/;"	f	file:
listener_read_cb	./listener.c	/^listener_read_cb(evutil_socket_t fd, short what, void *p)$/;"	f	file:
load_nameservers_from_registry	./evdns.c	/^load_nameservers_from_registry(struct evdns_base *base)$/;"	f	file:
load_nameservers_with_getnetworkparams	./evdns.c	/^load_nameservers_with_getnetworkparams(struct evdns_base *base)$/;"	f	file:
lock	./evdns.c	/^	void *lock;$/;"	m	struct:evdns_base	file:
lock	./evdns.c	/^	void *lock;$/;"	m	struct:evdns_server_port	file:
lock	./evthread.c	/^	void *lock;$/;"	m	struct:debug_lock	file:
lock	./evthread_win32.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:evthread_win32_cond	file:
lock	./listener.c	/^	CRITICAL_SECTION lock;$/;"	m	struct:accepting_socket	file:
lock	./listener.c	/^	void *lock;$/;"	m	struct:evconnlistener	file:
locktype	./evthread.c	/^	unsigned locktype;$/;"	m	struct:debug_lock	file:
log	./evdns.c	473;"	d	file:
log_fn	./log.c	/^static event_log_cb log_fn = NULL;$/;"	v	file:
loop	./event_iocp.c	/^loop(void *_port)$/;"	f	file:
lseek	./buffer.c	2898;"	d	file:
make_addrinfo	./http.c	/^make_addrinfo(const char *address, ev_uint16_t port)$/;"	f	file:
methods_bufferevent	./bufferevent_openssl.c	/^static BIO_METHOD methods_bufferevent = {$/;"	v	file:
mode_t	./evutil.c	88;"	d	file:
msg	./evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon7	file:
n_accepting	./listener.c	/^	short n_accepting;$/;"	m	struct:evconnlistener_iocp	file:
n_additional	./evdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:
n_answer	./evdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:
n_authority	./evdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:
n_buffers	./buffer_iocp.c	/^	int n_buffers;$/;"	m	struct:evbuffer_overlapped	file:
n_errors	./bufferevent_openssl.c	/^	unsigned n_errors : 2;$/;"	m	struct:bufferevent_openssl	file:
n_labels	./evdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:
n_read	./bufferevent_openssl.c	/^	unsigned long n_read;$/;"	m	struct:bio_data_counts	file:
n_req_heads	./evdns.c	/^	int n_req_heads;$/;"	m	struct:evdns_base	file:
n_to_wake	./evthread_win32.c	/^	int n_to_wake;$/;"	m	struct:evthread_win32_cond	file:
n_waiting	./evthread_win32.c	/^	int n_waiting;$/;"	m	struct:evthread_win32_cond	file:
n_written	./bufferevent_openssl.c	/^	unsigned long n_written;$/;"	m	struct:bio_data_counts	file:
name	./evdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon1::__anon4	file:
name	./evdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:
name	./http.c	/^	const char *name;$/;"	m	struct:response_class	file:
name_from_addr	./http.c	/^name_from_addr(struct sockaddr *sa, ev_socklen_t salen,$/;"	f	file:
name_parse	./evdns.c	/^name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {$/;"	f	file:
nameserver	./evdns.c	/^struct nameserver {$/;"	s	file:
nameserver_failed	./evdns.c	/^nameserver_failed(struct nameserver *const ns, const char *msg) {$/;"	f	file:
nameserver_pick	./evdns.c	/^nameserver_pick(struct evdns_base *base) {$/;"	f	file:
nameserver_probe_callback	./evdns.c	/^nameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {$/;"	f	file:
nameserver_probe_failed	./evdns.c	/^nameserver_probe_failed(struct nameserver *const ns) {$/;"	f	file:
nameserver_prod_callback	./evdns.c	/^nameserver_prod_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:
nameserver_read	./evdns.c	/^nameserver_read(struct nameserver *ns) {$/;"	f	file:
nameserver_ready_callback	./evdns.c	/^nameserver_ready_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:
nameserver_send_probe	./evdns.c	/^nameserver_send_probe(struct nameserver *const ns) {$/;"	f	file:
nameserver_up	./evdns.c	/^nameserver_up(struct nameserver *const ns)$/;"	f	file:
nameserver_write_waiting	./evdns.c	/^nameserver_write_waiting(struct nameserver *ns, char waiting) {$/;"	f	file:
nchanges	./devpoll.c	/^	int nchanges;$/;"	m	struct:devpollop	file:
ndots	./evdns.c	/^	int ndots;$/;"	m	struct:search_state	file:
need_numeric_port_hack	./evutil.c	/^need_numeric_port_hack(void)$/;"	f	file:
need_numeric_port_hack_	./evutil.c	/^static int need_numeric_port_hack_=0;$/;"	v	file:
need_socktype_protocol_hack	./evutil.c	/^need_socktype_protocol_hack(void)$/;"	f	file:
need_socktype_protocol_hack_	./evutil.c	/^static int need_socktype_protocol_hack_=0;$/;"	v	file:
nevents	./devpoll.c	/^	int nevents;$/;"	m	struct:devpollop	file:
nevents	./epoll.c	/^	int nevents;$/;"	m	struct:epollop	file:
new_accepting_socket	./listener.c	/^new_accepting_socket(struct evconnlistener_iocp *lev, int family)$/;"	f	file:
next	./evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:
next	./evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::request	file:
next	./evdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:
next	./evdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:
next_pending	./evdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:
nfds	./poll.c	/^	int nfds;			\/* Highest number used *\/$/;"	m	struct:pollop	file:
notify_base_cbq_callback	./event.c	/^notify_base_cbq_callback(struct deferred_cb_queue *cb, void *baseptr)$/;"	f	file:
nread	./evmap.c	/^	ev_uint16_t nread;$/;"	m	struct:evmap_io	file:
ns	./evdns.c	/^	struct nameserver *ns;	\/* the server which we last sent it *\/$/;"	m	struct:request	typeref:struct:request::nameserver	file:
num_domains	./evdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:
num_fds_in_fd_sets	./win32select.c	/^	unsigned num_fds_in_fd_sets;$/;"	m	struct:win32op	file:
num_responses	./http.c	/^	size_t num_responses;$/;"	m	struct:response_class	file:
nwrite	./evmap.c	/^	ev_uint16_t nwrite;$/;"	m	struct:evmap_io	file:
ok	./bufferevent_async.c	/^	unsigned ok : 1;$/;"	m	struct:bufferevent_async	file:
open	./evutil.c	83;"	d	file:
ops	./listener.c	/^	const struct evconnlistener_ops *ops;$/;"	m	struct:evconnlistener	typeref:struct:evconnlistener::evconnlistener_ops	file:
outbuf_cb	./bufferevent_filter.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::evbuffer_cb_entry	file:
outbuf_cb	./bufferevent_openssl.c	/^	struct evbuffer_cb_entry *outbuf_cb;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::evbuffer_cb_entry	file:
overlapped	./listener.c	/^	struct event_overlapped overlapped;$/;"	m	struct:accepting_socket	typeref:struct:accepting_socket::event_overlapped	file:
parse_authority	./http.c	/^parse_authority(struct evhttp_uri *uri, char *s, char *eos)$/;"	f	file:
parse_numeric_servname	./evutil.c	/^parse_numeric_servname(const char *servname)$/;"	f	file:
parse_port	./http.c	/^parse_port(const char *s, const char *eos)$/;"	f	file:
partner	./bufferevent_pair.c	/^	struct bufferevent_pair *partner;$/;"	m	struct:bufferevent_pair	typeref:struct:bufferevent_pair::bufferevent_pair	file:
path	./http.c	/^	char *path; \/* path, or "". *\/$/;"	m	struct:evhttp_uri	file:
path_matches_noscheme	./http.c	/^path_matches_noscheme(const char *cp)$/;"	f	file:
pending_cb	./evdns.c	/^	int pending_cb; \/* Waiting for its callback to be invoked; not$/;"	m	struct:evdns_request	file:
pending_error	./evdns.c	/^	int pending_error;$/;"	m	struct:evdns_getaddrinfo_request	file:
pending_replies	./evdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:
pending_result	./evdns.c	/^	struct evutil_addrinfo *pending_result;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::evutil_addrinfo	file:
pid	./kqueue.c	/^	pid_t pid;$/;"	m	struct:kqop	file:
pid_t	./arc4random.c	84;"	d	file:
pin_release	./buffer_iocp.c	/^pin_release(struct evbuffer_overlapped *eo, unsigned flag)$/;"	f	file:
poll_add	./poll.c	/^poll_add(struct event_base *base, int fd, short old, short events, void *_idx)$/;"	f	file:
poll_check_ok	./poll.c	/^poll_check_ok(struct pollop *pop)$/;"	f	file:
poll_check_ok	./poll.c	115;"	d	file:
poll_dealloc	./poll.c	/^poll_dealloc(struct event_base *base)$/;"	f	file:
poll_del	./poll.c	/^poll_del(struct event_base *base, int fd, short old, short events, void *_idx)$/;"	f	file:
poll_dispatch	./poll.c	/^poll_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
poll_init	./poll.c	/^poll_init(struct event_base *base)$/;"	f	file:
pollidx	./poll.c	/^struct pollidx {$/;"	s	file:
pollop	./poll.c	/^struct pollop {$/;"	s	file:
pollops	./poll.c	/^const struct eventop pollops = {$/;"	v	typeref:struct:eventop
port	./evdns.c	/^	ev_uint16_t port;$/;"	m	struct:evdns_getaddrinfo_request	file:
port	./evdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:
port	./http.c	/^	int port; \/* port, or zero *\/$/;"	m	struct:evhttp_uri	file:
port	./listener.c	/^	struct event_iocp_port *port;$/;"	m	struct:evconnlistener_iocp	typeref:struct:evconnlistener_iocp::event_iocp_port	file:
pos	./evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:
prefix_suffix_match	./http.c	/^prefix_suffix_match(const char *pattern, const char *name, int ignorecase)$/;"	f	file:
prev	./evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:
prev	./evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::	file:
prev_pending	./evdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:
print_err	./bufferevent_openssl.c	99;"	d	file:
probe_request	./evdns.c	/^	struct evdns_request *probe_request;$/;"	m	struct:nameserver	typeref:struct:nameserver::evdns_request	file:
process_in	./bufferevent_filter.c	/^	bufferevent_filter_cb process_in;$/;"	m	struct:bufferevent_filtered	file:
process_out	./bufferevent_filter.c	/^	bufferevent_filter_cb process_out;$/;"	m	struct:bufferevent_filtered	file:
ptr	./evdns.c	/^		} ptr;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon4	file:
ptr	./event.c	/^	const struct event *ptr;$/;"	m	struct:event_debug_entry	typeref:struct:event_debug_entry::event	file:
put_cname_in_ptr	./evdns.c	/^	char **put_cname_in_ptr; \/* store the cname here if we get one. *\/$/;"	m	struct:request	file:
put_error	./bufferevent_openssl.c	/^put_error(struct bufferevent_openssl *bev_ssl, unsigned long err)$/;"	f	file:
query	./http.c	/^	char *query; \/* query, or NULL *\/$/;"	m	struct:evhttp_uri	file:
r	./evdns.c	/^	struct evdns_request *r;$/;"	m	struct:getaddrinfo_subrequest	typeref:struct:getaddrinfo_subrequest::evdns_request	file:
rcsid	./strlcpy.c	/^static char *rcsid = "$OpenBSD: strlcpy.c,v 1.5 2001\/05\/13 15:40:16 deraadt Exp $";$/;"	v	file:
read	./evutil.c	84;"	d	file:
read_added	./bufferevent_async.c	/^	unsigned read_added : 1;$/;"	m	struct:bufferevent_async	file:
read_all	./arc4random.c	/^read_all(int fd, unsigned char *buf, size_t count)$/;"	f	file:
read_blocked_on_write	./bufferevent_openssl.c	/^	unsigned read_blocked_on_write : 1;$/;"	m	struct:bufferevent_openssl	file:
read_complete	./bufferevent_async.c	/^read_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:
read_in_progress	./buffer_iocp.c	/^	unsigned read_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:
read_in_progress	./bufferevent_async.c	/^	size_t read_in_progress;$/;"	m	struct:bufferevent_async	file:
read_overlapped	./bufferevent_async.c	/^	struct event_overlapped read_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:
read_pos_plus1	./win32select.c	/^	int read_pos_plus1;$/;"	m	struct:idx_info	file:
readset_in	./win32select.c	/^	struct win_fd_set *readset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:
readset_out	./win32select.c	/^	struct win_fd_set *readset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:
realloc_copy	./poll.c	/^	int realloc_copy;		\/* True iff we must realloc$/;"	m	struct:pollop	file:
reassociate	./evport.c	/^reassociate(struct evport_data *epdp, struct fd_info *fdip, int fd)$/;"	f	file:
redirection_phrases	./http.c	/^static const char *redirection_phrases[] = {$/;"	v	file:
refcnt	./evdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:
refcnt	./listener.c	/^	short refcnt;$/;"	m	struct:evconnlistener	file:
refcount	./evdns.c	/^	int refcount;$/;"	m	struct:search_state	file:
regname_ok	./http.c	/^regname_ok(const char *s, const char *eos)$/;"	f	file:
reissue_count	./evdns.c	/^	int reissue_count;$/;"	m	struct:request	file:
reply	./evdns.c	/^	struct reply reply;$/;"	m	struct:deferred_reply_callback	typeref:struct:deferred_reply_callback::reply	file:
reply	./evdns.c	/^struct reply {$/;"	s	file:
reply_handle	./evdns.c	/^reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {$/;"	f	file:
reply_parse	./evdns.c	/^reply_parse(struct evdns_base *base, u8 *packet, int length) {$/;"	f	file:
reply_run_callback	./evdns.c	/^reply_run_callback(struct deferred_cb *d, void *user_pointer)$/;"	f	file:
reply_schedule_callback	./evdns.c	/^reply_schedule_callback(struct request *const req, u32 ttl, u32 err, struct reply *reply)$/;"	f	file:
req_heads	./evdns.c	/^	struct request **req_heads;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:
req_waiting_head	./evdns.c	/^	struct request *req_waiting_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::request	file:
request	./evdns.c	/^	u8 *request;  \/* the dns packet data *\/$/;"	m	struct:request	file:
request	./evdns.c	/^struct request {$/;"	s	file:
request_appended	./evdns.c	/^	unsigned request_appended :1;	\/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:request	file:
request_done	./evdns.c	/^	unsigned request_done : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:
request_find_from_trans_id	./evdns.c	/^request_find_from_trans_id(struct evdns_base *base, u16 trans_id) {$/;"	f	file:
request_finished	./evdns.c	/^request_finished(struct request *const req, struct request **head, int free_handle) {$/;"	f	file:
request_len	./evdns.c	/^	unsigned int request_len;$/;"	m	struct:request	file:
request_new	./evdns.c	/^request_new(struct evdns_base *base, struct evdns_request *handle, int type,$/;"	f	file:
request_parse	./evdns.c	/^request_parse(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, ev_socklen_t addrlen)$/;"	f	file:
request_reissue	./evdns.c	/^request_reissue(struct request *req) {$/;"	f	file:
request_submit	./evdns.c	/^request_submit(struct request *const req) {$/;"	f	file:
request_trans_id_set	./evdns.c	/^request_trans_id_set(struct request *const req, const u16 trans_id) {$/;"	f	file:
request_type	./evdns.c	/^	u8 request_type; \/* TYPE_PTR or TYPE_A or TYPE_AAAA *\/$/;"	m	struct:request	file:
request_type	./evdns.c	/^	u8 request_type;$/;"	m	struct:deferred_reply_callback	file:
resize_out_sets	./select.c	/^	int resize_out_sets;$/;"	m	struct:selectop	file:
resize_out_sets	./win32select.c	/^	int resize_out_sets;$/;"	m	struct:win32op	file:
resolv_conf_parse_line	./evdns.c	/^resolv_conf_parse_line(struct evdns_base *base, char *const start, int flags) {$/;"	f	file:
response	./evdns.c	/^	char *response;$/;"	m	struct:server_request	file:
response_class	./http.c	/^struct response_class {$/;"	s	file:
response_classes	./http.c	/^static const struct response_class response_classes[] = {$/;"	v	typeref:struct:response_class	file:
response_len	./evdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:
responses	./http.c	/^	const char **responses;$/;"	m	struct:response_class	file:
rs	./arc4random.c	/^static struct arc4_stream rs;$/;"	v	typeref:struct:arc4_stream	file:
rs_initialized	./arc4random.c	/^static int rs_initialized;$/;"	v	file:
s	./arc4random.c	/^	unsigned char s[256];$/;"	m	struct:arc4_stream	file:
s	./listener.c	/^	SOCKET s;$/;"	m	struct:accepting_socket	file:
sa	./evdns.c	/^		struct sockaddr sa;$/;"	m	union:hosts_entry::__anon5	typeref:struct:hosts_entry::__anon5::sockaddr	file:
scheme	./http.c	/^	char *scheme; \/* scheme; e.g http, ftp etc *\/$/;"	m	struct:evhttp_uri	file:
scheme_ok	./http.c	/^scheme_ok(const char *s, const char *eos)$/;"	f	file:
search_domain	./evdns.c	/^struct search_domain {$/;"	s	file:
search_flags	./evdns.c	/^	int search_flags;$/;"	m	struct:evdns_request	file:
search_index	./evdns.c	/^	int search_index;$/;"	m	struct:evdns_request	file:
search_make_new	./evdns.c	/^search_make_new(const struct search_state *const state, int n, const char *const base_name) {$/;"	f	file:
search_origname	./evdns.c	/^	char *search_origname;	\/* needs to be free()ed *\/$/;"	m	struct:evdns_request	file:
search_postfix_add	./evdns.c	/^search_postfix_add(struct evdns_base *base, const char *domain) {$/;"	f	file:
search_postfix_clear	./evdns.c	/^search_postfix_clear(struct evdns_base *base) {$/;"	f	file:
search_request_finished	./evdns.c	/^search_request_finished(struct evdns_request *const handle) {$/;"	f	file:
search_request_new	./evdns.c	/^search_request_new(struct evdns_base *base, struct evdns_request *handle,$/;"	f	file:
search_reverse	./evdns.c	/^search_reverse(struct evdns_base *base) {$/;"	f	file:
search_set_from_hostname	./evdns.c	/^search_set_from_hostname(struct evdns_base *base) {$/;"	f	file:
search_state	./evdns.c	/^	struct search_state *search_state;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::search_state	file:
search_state	./evdns.c	/^struct search_state {$/;"	s	file:
search_state_decref	./evdns.c	/^search_state_decref(struct search_state *const state) {$/;"	f	file:
search_state_new	./evdns.c	/^search_state_new(void) {$/;"	f	file:
search_try_next	./evdns.c	/^search_try_next(struct evdns_request *const handle) {$/;"	f	file:
select_add	./select.c	/^select_add(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
select_dealloc	./select.c	/^select_dealloc(struct event_base *base)$/;"	f	file:
select_del	./select.c	/^select_del(struct event_base *base, int fd, short old, short events, void *p)$/;"	f	file:
select_dispatch	./select.c	/^select_dispatch(struct event_base *base, struct timeval *tv)$/;"	f	file:
select_free_selectop	./select.c	/^select_free_selectop(struct selectop *sop)$/;"	f	file:
select_init	./select.c	/^select_init(struct event_base *base)$/;"	f	file:
select_resize	./select.c	/^select_resize(struct selectop *sop, int fdsz)$/;"	f	file:
selectop	./select.c	/^struct selectop {$/;"	s	file:
selectops	./select.c	/^const struct eventop selectops = {$/;"	v	typeref:struct:eventop
server_error_phrases	./http.c	/^static const char *server_error_phrases[] = {$/;"	v	file:
server_head	./evdns.c	/^	struct nameserver *server_head;$/;"	m	struct:evdns_base	typeref:struct:evdns_base::nameserver	file:
server_port_flush	./evdns.c	/^server_port_flush(struct evdns_server_port *port)$/;"	f	file:
server_port_free	./evdns.c	/^server_port_free(struct evdns_server_port *port)$/;"	f	file:
server_port_read	./evdns.c	/^server_port_read(struct evdns_server_port *s) {$/;"	f	file:
server_port_ready_callback	./evdns.c	/^server_port_ready_callback(evutil_socket_t fd, short events, void *arg) {$/;"	f	file:
server_reply_item	./evdns.c	/^struct server_reply_item {$/;"	s	file:
server_request	./evdns.c	/^struct server_request {$/;"	s	file:
server_request_free	./evdns.c	/^server_request_free(struct server_request *req)$/;"	f	file:
server_request_free_answers	./evdns.c	/^server_request_free_answers(struct server_request *req)$/;"	f	file:
set_handshake_callbacks	./bufferevent_openssl.c	/^set_handshake_callbacks(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)$/;"	f	file:
set_open_callbacks	./bufferevent_openssl.c	/^set_open_callbacks(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)$/;"	f	file:
set_rbow	./bufferevent_openssl.c	/^set_rbow(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
set_wbor	./bufferevent_openssl.c	/^set_wbor(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
shutdown	./listener.c	/^	void (*shutdown)(struct evconnlistener *);$/;"	m	struct:evconnlistener_ops	file:
shutting_down	./listener.c	/^	unsigned shutting_down : 1;$/;"	m	struct:evconnlistener_iocp	file:
signals_are_broken	./win32select.c	/^	unsigned signals_are_broken : 1;$/;"	m	struct:win32op	file:
sin	./evdns.c	/^		struct sockaddr_in sin;$/;"	m	union:hosts_entry::__anon5	typeref:struct:hosts_entry::__anon5::sockaddr_in	file:
sin6	./evdns.c	/^		struct sockaddr_in6 sin6;$/;"	m	union:hosts_entry::__anon5	typeref:struct:hosts_entry::__anon5::sockaddr_in6	file:
sockaddr_getport	./evdns.c	/^sockaddr_getport(struct sockaddr *sa)$/;"	f	file:
sockaddr_setport	./evdns.c	/^sockaddr_setport(struct sockaddr *sa, ev_uint16_t port)$/;"	f	file:
socket	./evdns.c	/^	evutil_socket_t socket;	 \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:
socket	./evdns.c	/^	evutil_socket_t socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:
ssize_t	./evutil_rand.c	111;"	d	file:
ssl	./bufferevent_openssl.c	/^	SSL *ssl;$/;"	m	struct:bufferevent_openssl	file:
start_accepting	./listener.c	/^start_accepting(struct accepting_socket *as)$/;"	f	file:
start_reading	./bufferevent_openssl.c	/^start_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
start_writing	./bufferevent_openssl.c	/^start_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
stat	./evutil.c	87;"	d	file:
state	./bufferevent_openssl.c	/^	unsigned state : 2;$/;"	m	struct:bufferevent_openssl	file:
state	./evdns.c	/^	char state;  \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:
stop_accepting	./listener.c	/^stop_accepting(struct accepting_socket *as)$/;"	f	file:
stop_reading	./bufferevent_openssl.c	/^stop_reading(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
stop_writing	./bufferevent_openssl.c	/^stop_writing(struct bufferevent_openssl *bev_ssl)$/;"	f	file:
str_matches_option	./evdns.c	/^str_matches_option(const char *s1, const char *optionname)$/;"	f	file:
string_num_dots	./evdns.c	/^string_num_dots(const char *s) {$/;"	f	file:
strsep	./http.c	/^strsep(char **s, const char *del)$/;"	f	file:
strtoint	./evdns.c	/^strtoint(const char *const str)$/;"	f	file:
strtoint_clipped	./evdns.c	/^strtoint_clipped(const char *const str, int min, int max)$/;"	f	file:
strtok_r	./evdns.c	/^strtok_r(char *s, const char *delim, char **state) {$/;"	f	file:
strtotimeval	./evdns.c	/^strtotimeval(const char *const str, struct timeval *out)$/;"	f	file:
success_phrases	./http.c	/^static const char *success_phrases[] = {$/;"	v	file:
test_for_getaddrinfo_hacks	./evutil.c	/^test_for_getaddrinfo_hacks(void)$/;"	f	file:
tested_for_getaddrinfo_hacks	./evutil.c	/^static int tested_for_getaddrinfo_hacks=0;$/;"	v	file:
the_extension_fns	./event_iocp.c	/^static struct win32_extension_fns the_extension_fns;$/;"	v	typeref:struct:win32_extension_fns	file:
timedout	./evdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:
timeout	./evdns.c	/^	struct event timeout;$/;"	m	struct:evdns_getaddrinfo_request	typeref:struct:evdns_getaddrinfo_request::event	file:
timeout_correct	./event.c	/^timeout_correct(struct event_base *base, struct timeval *tv)$/;"	f	file:
timeout_event	./evdns.c	/^	struct event timeout_event;  \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:
timeout_event	./evdns.c	/^	struct event timeout_event;$/;"	m	struct:request	typeref:struct:request::event	file:
timeout_initialized	./http.c	87;"	d	file:
timeout_next	./event.c	/^timeout_next(struct event_base *base, struct timeval **tv_p)$/;"	f	file:
timeout_pending	./http.c	86;"	d	file:
timeout_process	./event.c	/^timeout_process(struct event_base *base)$/;"	f	file:
trans_id	./evdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:request	file:
trans_id	./evdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:
transaction_id_pick	./evdns.c	/^transaction_id_pick(struct evdns_base *base) {$/;"	f	file:
transmit_me	./evdns.c	/^	unsigned transmit_me :1;  \/* needs to be transmitted *\/$/;"	m	struct:request	file:
ttl	./evdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:
ttl	./evdns.c	/^	u32 ttl;$/;"	m	struct:deferred_reply_callback	file:
tx_count	./evdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:request	file:
type	./evdns.c	/^	ev_uint32_t type;$/;"	m	struct:getaddrinfo_subrequest	file:
type	./evdns.c	/^	u16 type; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:
type	./evdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:
u16	./evdns.c	138;"	d	file:
u32	./evdns.c	137;"	d	file:
u64	./evdns.c	136;"	d	file:
u8	./evdns.c	139;"	d	file:
underlying	./bufferevent_filter.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_filtered	typeref:struct:bufferevent_filtered::bufferevent	file:
underlying	./bufferevent_openssl.c	/^	struct bufferevent *underlying;$/;"	m	struct:bufferevent_openssl	typeref:struct:bufferevent_openssl::bufferevent	file:
upcast	./bufferevent_async.c	/^upcast(struct bufferevent *bev)$/;"	f	file:
upcast	./bufferevent_filter.c	/^upcast(struct bufferevent *bev)$/;"	f	file:
upcast	./bufferevent_openssl.c	/^upcast(struct bufferevent *bev)$/;"	f	file:
upcast	./bufferevent_pair.c	/^upcast(struct bufferevent *bev)$/;"	f	file:
upcast_connect	./bufferevent_async.c	/^upcast_connect(struct event_overlapped *eo)$/;"	f	file:
upcast_evbuffer	./buffer_iocp.c	/^upcast_evbuffer(struct evbuffer *buf)$/;"	f	file:
upcast_read	./bufferevent_async.c	/^upcast_read(struct event_overlapped *eo)$/;"	f	file:
upcast_write	./bufferevent_async.c	/^upcast_write(struct event_overlapped *eo)$/;"	f	file:
update_time_cache	./event.c	/^update_time_cache(struct event_base *base)$/;"	f	file:
uri_chars	./http.c	/^static const char uri_chars[256] = {$/;"	v	file:
uri_part	./http.c	/^enum uri_part {$/;"	g	file:
use_mmap	./buffer.c	/^static int use_mmap = 1;$/;"	v	file:
use_monotonic	./event.c	/^static int use_monotonic;$/;"	v	file:
use_sendfile	./buffer.c	/^static int use_sendfile = 1;$/;"	v	file:
user_callback	./evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:deferred_reply_callback	file:
user_callback	./evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:request	file:
user_callback	./evdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:
user_canceled	./evdns.c	/^	unsigned user_canceled : 1;$/;"	m	struct:evdns_getaddrinfo_request	file:
user_cb	./evdns.c	/^	evdns_getaddrinfo_cb user_cb;$/;"	m	struct:evdns_getaddrinfo_request	file:
user_data	./evdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:
user_data	./evdns.c	/^	void *user_data;$/;"	m	struct:evdns_getaddrinfo_request	file:
user_data	./listener.c	/^	void *user_data;$/;"	m	struct:evconnlistener	file:
user_pointer	./evdns.c	/^	void *user_pointer;  \/* the pointer given to us for this request *\/$/;"	m	struct:request	file:
userinfo	./http.c	/^	char *userinfo; \/* userinfo (typically username:pass), or NULL *\/$/;"	m	struct:evhttp_uri	file:
userinfo_ok	./http.c	/^userinfo_ok(const char *s, const char *eos)$/;"	f	file:
v	./evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:
va_copy	./buffer.c	2693;"	d	file:
win32_add	./win32select.c	/^win32_add(struct event_base *base, evutil_socket_t fd,$/;"	f
win32_dealloc	./win32select.c	/^win32_dealloc(struct event_base *_base)$/;"	f
win32_del	./win32select.c	/^win32_del(struct event_base *base, evutil_socket_t fd, short old, short events,$/;"	f
win32_dispatch	./win32select.c	/^win32_dispatch(struct event_base *base, struct timeval *tv)$/;"	f
win32_init	./win32select.c	/^win32_init(struct event_base *_base)$/;"	f
win32op	./win32select.c	/^struct win32op {$/;"	s	file:
win32ops	./win32select.c	/^struct eventop win32ops = {$/;"	v	typeref:struct:eventop
win_fd_set	./win32select.c	/^struct win_fd_set {$/;"	s	file:
windows_socket_errors	./evutil.c	/^static struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	v	typeref:struct:__anon7	file:
write_added	./bufferevent_async.c	/^	unsigned write_added : 1;$/;"	m	struct:bufferevent_async	file:
write_blocked_on_read	./bufferevent_openssl.c	/^	unsigned write_blocked_on_read : 1;$/;"	m	struct:bufferevent_openssl	file:
write_complete	./bufferevent_async.c	/^write_complete(struct event_overlapped *eo, ev_uintptr_t key,$/;"	f	file:
write_in_progress	./buffer_iocp.c	/^	unsigned write_in_progress : 1;$/;"	m	struct:evbuffer_overlapped	file:
write_in_progress	./bufferevent_async.c	/^	size_t write_in_progress;$/;"	m	struct:bufferevent_async	file:
write_overlapped	./bufferevent_async.c	/^	struct event_overlapped write_overlapped;$/;"	m	struct:bufferevent_async	typeref:struct:bufferevent_async::event_overlapped	file:
write_pos_plus1	./win32select.c	/^	int write_pos_plus1;$/;"	m	struct:idx_info	file:
write_waiting	./evdns.c	/^	char write_waiting;  \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:
writeset_in	./win32select.c	/^	struct win_fd_set *writeset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:
writeset_out	./win32select.c	/^	struct win_fd_set *writeset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:
